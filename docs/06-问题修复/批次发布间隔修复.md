# 批次发布间隔修复

## 问题描述

发布任务时，定时失效，发布时没有按照定时间隔发送。

## 问题分析

### 根本原因

在 `client/src/pages/PublishingTasksPage.tsx` 的 `handleCreateTasks` 函数中，批次任务的 `batch_order` 分配逻辑有误：

```typescript
// 原来的错误代码
for (let i = 0; i < articleIds.length; i++) {
  const articleId = articleIds[i];
  
  for (const accountId of accountIds) {
    // 创建任务，使用相同的 batch_order
    tasks.push(createPublishingTask({
      batch_order: batchOrder,  // ❌ 问题：同一文章的多个账号任务使用相同的 order
      interval_minutes: publishInterval,
      ...
    }));
  }
  
  batchOrder++;  // ❌ 只在外层循环增加
}
```

### 问题影响

1. **同时执行**：当选择多个账号时，同一篇文章的多个任务（不同账号）会有相同的 `batch_order`
2. **忽略间隔**：`BatchExecutor` 按 `batch_order` 排序执行，相同 order 的任务会被同时执行
3. **定时失效**：`interval_minutes` 只在不同 order 的任务之间生效

### 示例场景

假设选择：
- 2篇文章（A、B）
- 2个账号（账号1、账号2）
- 间隔5分钟

**错误的执行顺序：**
```
batch_order=0: 文章A-账号1, 文章A-账号2  ← 同时执行
等待5分钟
batch_order=1: 文章B-账号1, 文章B-账号2  ← 同时执行
```

**正确的执行顺序：**
```
batch_order=0: 文章A-账号1
等待5分钟
batch_order=1: 文章A-账号2
等待5分钟
batch_order=2: 文章B-账号1
等待5分钟
batch_order=3: 文章B-账号2
```

## 修复方案

### 1. 修复 batch_order 分配逻辑

将 `batchOrder++` 移到内层循环，确保每个任务都有唯一的顺序号：

```typescript
// 修复后的代码
for (let i = 0; i < articleIds.length; i++) {
  const articleId = articleIds[i];
  
  for (const accountId of accountIds) {
    const account = accounts.find(a => a.id === accountId);
    if (account) {
      tasks.push(
        createPublishingTask({
          article_id: articleId,
          platform_id: account.platform_id,
          account_id: accountId,
          scheduled_time: null,
          batch_id: batchId,
          batch_order: batchOrder,
          interval_minutes: publishInterval,
          config: {
            headless: headlessMode
          }
        })
      );
      
      // ✅ 每创建一个任务就增加 batch_order
      batchOrder++;
    }
  }
}
```

### 2. 修复总耗时计算

更新预计完成时间的计算，使用总任务数而不是文章数：

```typescript
// 修复前
const totalMinutes = (articleIds.length - 1) * publishInterval;

// 修复后
const totalMinutes = (totalTasks - 1) * publishInterval;
```

### 3. 更新提示文案

```typescript
// 修复前
⚠️ 串行发布：第一篇文章发布完成后，等待 {publishInterval} 分钟，再发布第二篇，依此类推

// 修复后
⚠️ 串行发布：每个任务完成后，等待 {publishInterval} 分钟，再发布下一个任务
```

## 修改文件

- `client/src/pages/PublishingTasksPage.tsx`
  - 修复 `handleCreateTasks` 函数中的 `batch_order` 分配逻辑
  - 修复总耗时计算公式
  - 更新确认对话框的提示文案

## 验证方法

### 测试场景

1. 选择 2 篇文章
2. 选择 2 个账号
3. 设置间隔 1 分钟
4. 创建批次任务

### 预期结果

1. 创建 4 个任务，batch_order 分别为 0, 1, 2, 3
2. 任务按顺序执行：
   - 任务0 执行
   - 等待 1 分钟
   - 任务1 执行
   - 等待 1 分钟
   - 任务2 执行
   - 等待 1 分钟
   - 任务3 执行
3. 总耗时约 3 分钟（不包括任务执行时间）

### 检查数据库

```sql
-- 查看批次任务的 batch_order
SELECT id, article_id, account_id, batch_order, interval_minutes
FROM publishing_tasks
WHERE batch_id = 'batch_xxx'
ORDER BY batch_order;

-- 应该看到每个任务都有唯一的 batch_order
```

## 相关代码

### BatchExecutor 执行逻辑

`server/src/services/BatchExecutor.ts` 中的执行逻辑：

```typescript
// 获取批次中的所有任务，按 batch_order 排序
const tasks = await publishingService.getBatchTasks(batchId);

// 按顺序执行每个任务
for (let i = 0; i < tasks.length; i++) {
  const task = tasks[i];
  
  // 执行任务
  await publishingExecutor.executeTask(task.id);
  
  // 如果不是最后一个任务，等待间隔时间
  if (i < tasks.length - 1) {
    const intervalMinutes = task.interval_minutes || 0;
    await this.waitWithStopCheck(batchId, intervalMinutes);
  }
}
```

### PublishingService 查询逻辑

`server/src/services/PublishingService.ts` 中的查询：

```typescript
async getBatchTasks(batchId: string): Promise<PublishingTask[]> {
  const result = await pool.query(
    `SELECT * FROM publishing_tasks 
     WHERE batch_id = $1 
     ORDER BY batch_order ASC`,  // ← 按 batch_order 排序
    [batchId]
  );
  
  return result.rows.map(row => this.formatTask(row));
}
```

## 总结

这个问题的核心是 **batch_order 的分配逻辑错误**，导致多个任务被分配了相同的顺序号，从而同时执行而不是按间隔执行。

修复后，每个任务都会有唯一的 `batch_order`，确保 `BatchExecutor` 能够按照正确的顺序和间隔执行所有任务。
