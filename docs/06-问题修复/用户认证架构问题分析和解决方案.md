# 用户认证架构问题分析和解决方案

**日期**: 2026-01-19  
**问题**: 用户信息存储混乱导致数据查询错误

---

## 用户提出的关键问题

1. **Win的用户为什么不存储在数据库中？**
2. **服务器的用户是不是存在服务器中？**
3. **为什么我已经登录了aizhiruan而win数据库却没有保存？只保存了zhuangxiu？**
4. **是因为用户数据存储在缓存中才导致无法同步显示蒸馏结果吗？**
5. **互联网最佳实践是什么？**

---

## 当前架构问题分析

### 问题 1: 用户信息存储位置混乱

**当前状态**：

| 存储位置 | 存储内容 | 用途 | 问题 |
|---------|---------|------|------|
| **服务器 PostgreSQL** | 完整用户表 | 认证、授权、配额管理 | ✅ 正确 |
| **Windows 本地 PostgreSQL** | ❌ 无用户表 | - | ❌ 缺失 |
| **Electron Store (JSON)** | 用户基本信息 | IPC 查询时获取 user_id | ❌ 容易过期 |
| **localStorage** | 用户基本信息 | 前端权限判断 | ❌ 容易不同步 |

**问题根源**：
- ✅ 服务器有用户数据（正确）
- ❌ Windows 端没有用户表（错误）
- ❌ 用户信息分散在 3 个地方（Electron Store、localStorage、内存）
- ❌ 没有单一数据源（Single Source of Truth）

### 问题 2: 数据同步混乱

**当前流程**：

```
登录成功
  ↓
服务器返回 token + 用户信息
  ↓
保存到 Electron Store (user_id=1, username=aizhiruan)
  ↓
保存到 localStorage (user_id=1, username=aizhiruan)
  ↓
【问题】如果之前登录过其他用户，Electron Store 可能没有更新
  ↓
IPC 查询时从 Electron Store 读取 user_id=5 (旧数据)
  ↓
查询数据库时使用错误的 user_id
  ↓
显示错误的数据或无数据
```

### 问题 3: 为什么 Windows 数据库没有保存 aizhiruan？

**答案**: Windows 本地数据库**根本没有用户表**！

```sql
-- Windows 本地数据库 (geo_windows) 的表
\dt

-- 结果：没有 users 表！
 public | distillations       | table | lzc
 public | topics              | table | lzc
 public | articles            | table | lzc
 public | knowledge_bases     | table | lzc
 ...
```

**为什么没有用户表？**
- 设计时认为用户信息只需要服务器存储
- Windows 端只需要 user_id 来关联数据
- 但这导致了**数据一致性问题**

### 问题 4: 缓存导致的同步问题

**是的！** 这正是问题的核心：

1. **Electron Store 是缓存**，不是数据库
2. **缓存可能过期**，但没有自动刷新机制
3. **多个缓存位置**（Electron Store + localStorage）导致不一致
4. **没有验证机制**，不检查缓存是否与服务器一致

---

## 互联网最佳实践

### 1. Single Source of Truth (单一数据源)

**原则**: 每个数据只有一个权威来源

**最佳实践**：

```
用户信息的权威来源：
  ├─ 服务器 PostgreSQL (主数据源) ✅
  └─ Windows 本地 PostgreSQL (副本，用于离线) ✅

缓存只用于性能优化，不作为数据源：
  ├─ Electron Store (临时缓存) ⚠️
  └─ localStorage (临时缓存) ⚠️
```

**参考**: 
- [Designing offline-first sync](https://softwareengineering.stackexchange.com/questions/460701) - 离线优先的同步设计
- [Local-first architecture](https://www.francescatabor.com/articles/2025/12/29/one-architecture-many-products-what-you-can-build-with-a-local-first-realtime-stack) - 本地优先架构

### 2. 用户信息应该存储在本地数据库

**原因**：

1. **数据一致性**: 数据库保证 ACID 特性
2. **关联查询**: 可以直接 JOIN 用户表
3. **离线能力**: 即使断网也能查询用户信息
4. **避免缓存过期**: 数据库不会"过期"

**最佳实践**：

```sql
-- Windows 本地数据库应该有用户表
CREATE TABLE users (
    id INTEGER PRIMARY KEY,  -- 与服务器同步的 user_id
    username VARCHAR(50) NOT NULL,
    email VARCHAR(100),
    role VARCHAR(20) NOT NULL,
    synced_at TIMESTAMP DEFAULT NOW(),  -- 最后同步时间
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW()
);

-- 蒸馏表可以直接关联用户表
CREATE TABLE distillations (
    id SERIAL PRIMARY KEY,
    user_id INTEGER NOT NULL,  -- 关联到 users.id
    keyword TEXT NOT NULL,
    topic_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 创建索引
CREATE INDEX idx_distillations_user_id ON distillations(user_id);
```

### 3. 登录时同步用户信息到本地数据库

**最佳实践**：

```typescript
// 登录成功后
async function handleLoginSuccess(response: LoginResponse) {
  const { user, accessToken, refreshToken } = response;
  
  // 1. 保存 tokens 到 Electron Store（加密）
  await window.electron.storage.saveTokens({
    authToken: accessToken,
    refreshToken: refreshToken
  });
  
  // 2. ⭐ 同步用户信息到本地数据库（新增）
  await window.electron.invoke('user:sync', {
    id: user.id,
    username: user.username,
    email: user.email,
    role: user.role
  });
  
  // 3. 保存到 Electron Store（用于快速访问）
  await window.electron.storage.saveUser(user);
  
  // 4. 保存到 localStorage（用于前端权限判断）
  localStorage.setItem('user_info', JSON.stringify(user));
  
  console.log('✅ 用户信息已同步到所有位置');
}
```

### 4. IPC 查询时从本地数据库读取

**最佳实践**：

```typescript
// windows-login-manager/electron/ipc/handlers/localDistillationHandlers.ts

ipcMain.handle('distillation:getAll', async () => {
  try {
    // ❌ 旧方法：从 Electron Store 读取（可能过期）
    // const user = await storageManager.getUser();
    // const userId = user?.id;
    
    // ✅ 新方法：从 token 解析 user_id（最可靠）
    const tokens = await storageManager.getTokens();
    if (!tokens?.authToken) {
      throw new Error('未登录');
    }
    
    // 解析 JWT token 获取 user_id
    const decoded = jwt.decode(tokens.authToken) as { userId: number };
    const userId = decoded.userId;
    
    // 查询本地数据库
    const result = await pool.query(
      `SELECT d.*, u.username 
       FROM distillations d
       LEFT JOIN users u ON u.id = d.user_id
       WHERE d.user_id = $1
       ORDER BY d.created_at DESC`,
      [userId]
    );
    
    return result.rows;
  } catch (error) {
    logger.error('查询蒸馏记录失败:', error);
    throw error;
  }
});
```

### 5. 启动时验证数据一致性

**最佳实践**：

```typescript
// windows-login-manager/src/App.tsx

useEffect(() => {
  const validateUserConsistency = async () => {
    try {
      // 1. 从 token 获取 user_id
      const tokens = await window.electron.storage.getTokens();
      if (!tokens?.authToken) return;
      
      const decoded = jwt.decode(tokens.authToken) as { userId: number };
      const tokenUserId = decoded.userId;
      
      // 2. 从本地数据库获取用户信息
      const localUser = await window.electron.invoke('user:getById', tokenUserId);
      
      // 3. 如果本地没有，从服务器同步
      if (!localUser) {
        console.log('本地无用户信息，从服务器同步...');
        const serverUser = await apiClient.get('/api/auth/me');
        await window.electron.invoke('user:sync', serverUser.data);
      }
      
      // 4. 验证 Electron Store 和 localStorage 的一致性
      const storeUser = await window.electron.storage.getUser();
      if (storeUser?.id !== tokenUserId) {
        console.warn('Electron Store 用户信息不一致，更新中...');
        await window.electron.storage.saveUser(localUser || serverUser.data);
      }
      
      const lsUser = JSON.parse(localStorage.getItem('user_info') || 'null');
      if (lsUser?.id !== tokenUserId) {
        console.warn('localStorage 用户信息不一致，更新中...');
        localStorage.setItem('user_info', JSON.stringify(localUser || serverUser.data));
      }
      
      console.log('✅ 用户信息一致性验证通过');
    } catch (error) {
      console.error('用户信息一致性验证失败:', error);
      // 清除所有缓存，强制重新登录
      await handleLogout();
    }
  };
  
  validateUserConsistency();
}, []);
```

### 6. 退出时清除所有位置的用户信息

**最佳实践**：

```typescript
async function handleLogout() {
  try {
    // 1. 调用服务器登出接口
    await apiClient.post('/api/auth/logout');
  } finally {
    // 2. 清除 tokens
    await window.electron.storage.clearTokens();
    
    // 3. 清除 Electron Store
    await window.electron.storage.clearUser();
    
    // 4. 清除 localStorage
    localStorage.removeItem('user_info');
    localStorage.removeItem('auth_token');
    
    // 5. ⭐ 清除本地数据库的用户信息（可选）
    // await window.electron.invoke('user:clearAll');
    
    console.log('✅ 所有位置的用户信息已清除');
  }
}
```

---

## 推荐的解决方案

### 方案 A: 完整重构（推荐）⭐

**优点**: 彻底解决问题，符合最佳实践  
**缺点**: 需要较多开发工作

**步骤**：

1. **创建本地用户表**
   ```sql
   -- windows-login-manager/electron/database/migrations/XXX_create_users_table.sql
   CREATE TABLE users (
       id INTEGER PRIMARY KEY,
       username VARCHAR(50) NOT NULL UNIQUE,
       email VARCHAR(100),
       role VARCHAR(20) NOT NULL,
       synced_at TIMESTAMP DEFAULT NOW(),
       created_at TIMESTAMP DEFAULT NOW(),
       updated_at TIMESTAMP DEFAULT NOW()
   );
   ```

2. **实现用户同步 IPC**
   ```typescript
   // windows-login-manager/electron/ipc/handlers/userHandlers.ts
   ipcMain.handle('user:sync', async (event, userData) => {
     // UPSERT 用户信息到本地数据库
   });
   
   ipcMain.handle('user:getById', async (event, userId) => {
     // 从本地数据库查询用户
   });
   ```

3. **修改登录流程**
   - 登录成功后同步用户信息到本地数据库
   - 更新 Electron Store 和 localStorage

4. **修改 IPC 查询逻辑**
   - 从 JWT token 解析 user_id（最可靠）
   - 或从本地数据库查询用户信息

5. **添加启动时验证**
   - 检查数据一致性
   - 自动修复不一致的数据

### 方案 B: 快速修复（临时）

**优点**: 快速解决当前问题  
**缺点**: 不彻底，仍有隐患

**步骤**：

1. **修改 IPC 查询逻辑**
   ```typescript
   // 从 JWT token 解析 user_id，而不是从 Electron Store
   const tokens = await storageManager.getTokens();
   const decoded = jwt.decode(tokens.authToken);
   const userId = decoded.userId;
   ```

2. **添加登录时强制更新**
   ```typescript
   // 登录成功后强制更新 Electron Store
   await storageManager.saveUser(user);
   ```

3. **添加启动时验证**
   ```typescript
   // 检查 Electron Store 和 token 的一致性
   // 不一致时清除 Store 并重新登录
   ```

---

## 实施计划

### 阶段 1: 立即修复（今天）

**目标**: 解决当前用户看不到蒸馏结果的问题

**步骤**：
1. ✅ 用户重新登录（刷新 Electron Store）
2. ⏳ 修改 IPC 查询逻辑（从 token 解析 user_id）
3. ⏳ 编译并测试

**预计时间**: 1 小时

### 阶段 2: 短期优化（本周）

**目标**: 防止问题再次发生

**步骤**：
1. ⏳ 添加登录时强制更新 Electron Store
2. ⏳ 添加启动时验证数据一致性
3. ⏳ 添加退出时清除所有缓存

**预计时间**: 2-3 小时

### 阶段 3: 长期重构（下周）

**目标**: 实现最佳实践架构

**步骤**：
1. ⏳ 创建本地用户表
2. ⏳ 实现用户同步机制
3. ⏳ 修改所有 IPC 查询逻辑
4. ⏳ 完整测试

**预计时间**: 1-2 天

---

## 技术细节

### JWT Token 解析

```typescript
import jwt from 'jsonwebtoken';

// 解析 JWT token（不验证签名，只读取 payload）
function getUserIdFromToken(token: string): number {
  try {
    const decoded = jwt.decode(token) as { userId: number; exp: number };
    
    // 检查是否过期
    if (decoded.exp * 1000 < Date.now()) {
      throw new Error('Token 已过期');
    }
    
    return decoded.userId;
  } catch (error) {
    throw new Error('Token 无效');
  }
}
```

### 用户信息同步

```typescript
// UPSERT 用户信息到本地数据库
async function syncUserToLocal(user: UserInfo): Promise<void> {
  await pool.query(
    `INSERT INTO users (id, username, email, role, synced_at, updated_at)
     VALUES ($1, $2, $3, $4, NOW(), NOW())
     ON CONFLICT (id) DO UPDATE SET
       username = EXCLUDED.username,
       email = EXCLUDED.email,
       role = EXCLUDED.role,
       synced_at = NOW(),
       updated_at = NOW()`,
    [user.id, user.username, user.email, user.role]
  );
}
```

---

## 总结

### 问题根源

1. ❌ Windows 本地数据库没有用户表
2. ❌ 用户信息分散在多个位置（Electron Store、localStorage）
3. ❌ 没有单一数据源（Single Source of Truth）
4. ❌ 缓存可能过期，没有验证机制
5. ❌ IPC 查询使用不可靠的数据源（Electron Store）

### 解决方案

1. ✅ 创建本地用户表（长期）
2. ✅ 从 JWT token 解析 user_id（短期）
3. ✅ 登录时同步用户信息到所有位置
4. ✅ 启动时验证数据一致性
5. ✅ 退出时清除所有缓存

### 最佳实践

1. ✅ Single Source of Truth: 服务器 + 本地数据库
2. ✅ 缓存只用于性能优化，不作为数据源
3. ✅ 始终验证数据一致性
4. ✅ 从最可靠的来源读取数据（JWT token > 数据库 > 缓存）
5. ✅ 自动修复不一致的数据

---

## 参考资料

- [Designing offline-first sync for multi-user desktop app](https://softwareengineering.stackexchange.com/questions/460701)
- [Using JWT to authenticate users for an Electron app](https://stackoverflow.com/questions/72809373)
- [Local-first architecture patterns](https://www.francescatabor.com/articles/2025/12/29/one-architecture-many-products-what-you-can-build-with-a-local-first-realtime-stack)
- [Handling Auth in a Staging Environment](https://neon.com/blog/handling-auth-in-a-staging-environment)

---

**下一步**: 实施阶段 1（立即修复）
