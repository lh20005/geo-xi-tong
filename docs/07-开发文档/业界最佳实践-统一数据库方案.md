# 业界最佳实践：统一数据库方案

## 核心答案

**是的，可以统一使用一个数据库或互相兼容的数据库！** 业界已有成熟的解决方案。

## 业界最佳实践

### 方案 1：使用相同的数据库引擎 ⭐⭐⭐⭐⭐ 最推荐

#### 思路：客户端和服务器都使用 PostgreSQL

```
┌─────────────────────────────────────┐
│      Windows 桌面客户端              │
│  ┌──────────────────────────────┐   │
│  │   PostgreSQL (嵌入式)         │   │
│  │   - 本地运行                  │   │
│  │   - 完整的 PostgreSQL 功能    │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
              ↕ 逻辑复制
┌─────────────────────────────────────┐
│           服务器 (云端)              │
│  ┌──────────────────────────────┐   │
│  │   PostgreSQL (服务器版)       │   │
│  │   - 云端运行                  │   │
│  │   - 相同的 schema             │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
```

#### 实现方式

**使用 PostgreSQL 逻辑复制（Logical Replication）**

```sql
-- 服务器端：创建发布
CREATE PUBLICATION my_publication FOR ALL TABLES;

-- 客户端：创建订阅
CREATE SUBSCRIPTION my_subscription
CONNECTION 'host=server.com dbname=mydb user=myuser password=mypass'
PUBLICATION my_publication;
```

**优点**：
- ✅ 完全相同的 SQL 语法
- ✅ 相同的数据类型
- ✅ 原生的复制支持
- ✅ 强大的冲突解决机制
- ✅ 支持双向同步

**缺点**：
- ⚠️ PostgreSQL 嵌入式版本较大（~50MB）
- ⚠️ 资源消耗比 SQLite 高
- ⚠️ 需要管理 PostgreSQL 进程

**适用场景**：
- 企业级应用
- 数据一致性要求高
- 不在意客户端体积

**参考项目**：
- [Supabase](https://supabase.com/) - 使用 PostgreSQL 的 local-first 架构
- [Electric SQL](https://electric-sql.com/) - PostgreSQL 的本地优先同步

---

### 方案 2：使用兼容的数据库 + 同步层 ⭐⭐⭐⭐⭐ 最流行

#### 思路：PouchDB (客户端) + CouchDB (服务器)

```
┌─────────────────────────────────────┐
│      Windows 桌面客户端              │
│  ┌──────────────────────────────┐   │
│  │   PouchDB                     │   │
│  │   - 基于 IndexedDB/LevelDB   │   │
│  │   - 轻量级                    │   │
│  │   - 完全兼容 CouchDB          │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
              ↕ CouchDB 复制协议
┌─────────────────────────────────────┐
│           服务器 (云端)              │
│  ┌──────────────────────────────┐   │
│  │   CouchDB                     │   │
│  │   - 完全兼容 PouchDB          │   │
│  │   - 内置复制协议              │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
```

#### 实现代码

```typescript
// 客户端
import PouchDB from 'pouchdb';

// 本地数据库
const localDB = new PouchDB('myapp');

// 远程数据库
const remoteDB = new PouchDB('https://server.com/mydb', {
  auth: {
    username: 'user',
    password: 'pass'
  }
});

// 双向同步
localDB.sync(remoteDB, {
  live: true,  // 实时同步
  retry: true  // 自动重试
}).on('change', (info) => {
  console.log('数据变化:', info);
}).on('error', (err) => {
  console.error('同步错误:', err);
});
```

**优点**：
- ✅ 专为离线优先设计
- ✅ 自动冲突解决
- ✅ 轻量级（PouchDB ~50KB）
- ✅ 成熟稳定（10+ 年历史）
- ✅ 支持增量同步

**缺点**：
- ⚠️ 不支持 SQL（使用 JSON 文档）
- ⚠️ 需要改变数据模型
- ⚠️ 查询能力有限

**适用场景**：
- 文档型数据
- 离线优先应用
- 不需要复杂查询

**成功案例**：
- [IBM Cloudant](https://www.ibm.com/cloud/cloudant) - 基于 CouchDB
- [Obsidian LiveSync](https://github.com/vrtmrz/obsidian-livesync) - 笔记应用同步
- 医疗保健应用（离线诊断记录）

---

### 方案 3：RxDB - 现代化的本地优先数据库 ⭐⭐⭐⭐⭐ 最现代

#### 思路：RxDB (客户端) + 任意后端

```
┌─────────────────────────────────────┐
│      Windows 桌面客户端              │
│  ┌──────────────────────────────┐   │
│  │   RxDB                        │   │
│  │   - 基于 IndexedDB/SQLite    │   │
│  │   - 响应式（RxJS）            │   │
│  │   - 支持多种后端              │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
              ↕ GraphQL/REST/WebSocket
┌─────────────────────────────────────┐
│           服务器 (云端)              │
│  ┌──────────────────────────────┐   │
│  │   PostgreSQL / MongoDB        │   │
│  │   / Supabase / Hasura         │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
```

#### 实现代码

```typescript
import { createRxDatabase } from 'rxdb';
import { getRxStorageDexie } from 'rxdb/plugins/storage-dexie';
import { replicateGraphQL } from 'rxdb/plugins/replication-graphql';

// 创建本地数据库
const db = await createRxDatabase({
  name: 'myapp',
  storage: getRxStorageDexie()
});

// 添加集合
await db.addCollections({
  articles: {
    schema: articleSchema
  }
});

// 设置 GraphQL 复制
const replicationState = replicateGraphQL({
  collection: db.articles,
  url: {
    http: 'https://api.example.com/graphql',
    ws: 'wss://api.example.com/graphql'
  },
  pull: {
    queryBuilder: (doc) => ({
      query: `{
        articles(updatedAt: "${doc.updatedAt}") {
          id, title, content, updatedAt
        }
      }`
    })
  },
  push: {
    queryBuilder: (doc) => ({
      query: `mutation {
        updateArticle(id: "${doc.id}", data: {...}) {
          id, updatedAt
        }
      }`
    })
  },
  live: true
});
```

**优点**：
- ✅ 现代化架构（基于 RxJS）
- ✅ 支持多种存储引擎（IndexedDB, SQLite, Memory）
- ✅ 支持多种后端（GraphQL, REST, CouchDB）
- ✅ 强大的查询能力
- ✅ 自动冲突解决
- ✅ 加密支持

**缺点**：
- ⚠️ 学习曲线较陡
- ⚠️ 需要适配后端 API
- ⚠️ 商业功能需要付费

**适用场景**：
- 现代 Web/移动应用
- 需要响应式数据流
- 灵活的后端选择

**成功案例**：
- [Medplum](https://www.medplum.com/) - 医疗保健平台
- 多个企业级 SaaS 应用

---

### 方案 4：WatermelonDB - React Native 优化 ⭐⭐⭐⭐

#### 思路：专为移动端优化的本地优先数据库

```
┌─────────────────────────────────────┐
│      移动应用 / 桌面应用             │
│  ┌──────────────────────────────┐   │
│  │   WatermelonDB                │   │
│  │   - 基于 SQLite               │   │
│  │   - 懒加载                    │   │
│  │   - 高性能                    │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
              ↕ 自定义同步协议
┌─────────────────────────────────────┐
│           服务器 (云端)              │
│  ┌──────────────────────────────┐   │
│  │   任意数据库                  │   │
│  │   - 需要实现同步 API          │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
```

**优点**：
- ✅ 极高性能（10,000+ 记录）
- ✅ 懒加载（只加载需要的数据）
- ✅ 基于 SQLite（熟悉的 SQL）
- ✅ React/React Native 优化

**缺点**：
- ⚠️ 需要自己实现同步逻辑
- ⚠️ 主要针对移动端

**适用场景**：
- React Native 应用
- 大量数据的移动应用

---

### 方案 5：SQLite + 自定义同步 ⭐⭐⭐ 最灵活

#### 思路：保持 SQLite，但统一 schema 并实现同步

```
┌─────────────────────────────────────┐
│      Windows 桌面客户端              │
│  ┌──────────────────────────────┐   │
│  │   SQLite                      │   │
│  │   - 相同的 schema             │   │
│  │   - 添加同步元数据            │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
              ↕ 自定义同步 API
┌─────────────────────────────────────┐
│           服务器 (云端)              │
│  ┌──────────────────────────────┐   │
│  │   PostgreSQL                  │   │
│  │   - 兼容的 schema             │   │
│  │   - 同步 API                  │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘
```

#### 实现要点

**1. 统一 Schema**

```sql
-- 客户端 SQLite
CREATE TABLE articles (
    id TEXT PRIMARY KEY,  -- UUID
    title TEXT NOT NULL,
    content TEXT,
    user_id INTEGER,
    -- 同步元数据
    _synced_at INTEGER,  -- 最后同步时间
    _modified_at INTEGER,  -- 最后修改时间
    _deleted INTEGER DEFAULT 0,  -- 软删除标记
    created_at INTEGER DEFAULT (strftime('%s', 'now'))
);

-- 服务器 PostgreSQL
CREATE TABLE articles (
    id UUID PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT,
    user_id INTEGER REFERENCES users(id),
    -- 同步元数据
    synced_at TIMESTAMP,
    modified_at TIMESTAMP DEFAULT NOW(),
    deleted BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW()
);
```

**2. 同步逻辑**

```typescript
// 同步服务
class SyncService {
  async sync() {
    // 1. Pull: 从服务器拉取变更
    const lastSyncTime = await this.getLastSyncTime();
    const serverChanges = await this.fetchServerChanges(lastSyncTime);
    await this.applyServerChanges(serverChanges);
    
    // 2. Push: 推送本地变更到服务器
    const localChanges = await this.getLocalChanges(lastSyncTime);
    await this.pushLocalChanges(localChanges);
    
    // 3. 更新同步时间
    await this.updateLastSyncTime();
  }
  
  async fetchServerChanges(since: number) {
    return await apiClient.get('/api/sync/changes', {
      params: { since }
    });
  }
  
  async applyServerChanges(changes: any[]) {
    for (const change of changes) {
      if (change.deleted) {
        await localDB.delete(change.id);
      } else {
        await localDB.upsert(change);
      }
    }
  }
  
  async getLocalChanges(since: number) {
    return await localDB.query(`
      SELECT * FROM articles 
      WHERE _modified_at > ? AND _synced_at IS NULL
    `, [since]);
  }
  
  async pushLocalChanges(changes: any[]) {
    await apiClient.post('/api/sync/push', { changes });
    
    // 标记为已同步
    for (const change of changes) {
      await localDB.update(change.id, {
        _synced_at: Date.now()
      });
    }
  }
}
```

**优点**：
- ✅ 完全控制同步逻辑
- ✅ 可以保持现有架构
- ✅ 灵活性最高

**缺点**：
- ⚠️ 需要自己实现所有同步逻辑
- ⚠️ 冲突解决需要自己处理
- ⚠️ 开发和维护成本高

---

## 推荐方案对比

| 方案 | 复杂度 | 性能 | 成熟度 | 学习曲线 | 推荐度 |
|------|--------|------|--------|----------|--------|
| PostgreSQL 逻辑复制 | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| PouchDB + CouchDB | ⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| RxDB | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| WatermelonDB | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐ |
| SQLite + 自定义同步 | ⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐ | ⭐⭐⭐ |

## 针对你的项目的建议

### 短期方案（1-2 周）⭐ 立即可行

**保持 SQLite + PostgreSQL，但统一 Schema**

```typescript
// 1. 统一 ID 格式为 UUID
// 客户端和服务器都使用 UUID

// 2. 添加同步元数据字段
ALTER TABLE articles ADD COLUMN synced_at TIMESTAMP;
ALTER TABLE articles ADD COLUMN modified_at TIMESTAMP;
ALTER TABLE articles ADD COLUMN deleted BOOLEAN DEFAULT FALSE;

// 3. 实现简单的同步 API
POST /api/sync/pull  // 拉取服务器变更
POST /api/sync/push  // 推送本地变更
```

**优点**：
- ✅ 最小改动
- ✅ 快速实施
- ✅ 解决当前问题

---

### 中期方案（1-3 个月）⭐⭐⭐ 推荐

**迁移到 RxDB**

**理由**：
1. 支持 SQLite 存储（保持现有数据）
2. 内置同步机制
3. 响应式数据流（与 React 完美配合）
4. 支持多种后端（可以继续使用 PostgreSQL）

**迁移步骤**：
```typescript
// 1. 安装 RxDB
npm install rxdb rxjs

// 2. 创建 RxDB 数据库（使用 SQLite 存储）
import { createRxDatabase } from 'rxdb';
import { getRxStorageSQLite } from 'rxdb-premium/plugins/storage-sqlite';

const db = await createRxDatabase({
  name: 'myapp',
  storage: getRxStorageSQLite({
    sqliteBasics: require('better-sqlite3')
  })
});

// 3. 定义 schema（与现有表结构对应）
const articleSchema = {
  version: 0,
  primaryKey: 'id',
  type: 'object',
  properties: {
    id: { type: 'string', maxLength: 36 },
    title: { type: 'string' },
    content: { type: 'string' },
    userId: { type: 'number' },
    createdAt: { type: 'string', format: 'date-time' }
  }
};

// 4. 设置复制
import { replicateGraphQL } from 'rxdb/plugins/replication-graphql';

const replicationState = replicateGraphQL({
  collection: db.articles,
  url: {
    http: 'https://api.example.com/graphql'
  },
  pull: {
    queryBuilder: pullQueryBuilder
  },
  push: {
    queryBuilder: pushQueryBuilder
  }
});
```

---

### 长期方案（3-6 个月）⭐⭐⭐⭐⭐ 最佳

**完全迁移到 PostgreSQL（客户端 + 服务器）**

**使用 [Electric SQL](https://electric-sql.com/) 或 [PowerSync](https://www.powersync.com/)**

```typescript
// Electric SQL 示例
import { electrify } from 'electric-sql/wa-sqlite';
import { schema } from './generated/client';

// 本地 PostgreSQL（通过 WASM）
const electric = await electrify(
  await initWasm(),
  schema,
  {
    url: 'https://electric.example.com'
  }
);

// 使用标准 SQL
const articles = await electric.db.articles.findMany({
  where: { userId: 1 }
});

// 自动同步
electric.sync.subscribe((status) => {
  console.log('同步状态:', status);
});
```

**优点**：
- ✅ 完全相同的数据库
- ✅ 完全相同的 SQL
- ✅ 自动同步
- ✅ 强大的查询能力
- ✅ 企业级可靠性

---

## 成功案例参考

### 1. Notion
- **架构**：客户端缓存 + 云端 PostgreSQL
- **同步**：自定义协议，实时同步
- **特点**：云端优先，但有离线缓存

### 2. Obsidian
- **架构**：完全本地（Markdown 文件）
- **同步**：可选的 CouchDB 同步（LiveSync 插件）
- **特点**：本地优先，数据完全控制

### 3. Linear
- **架构**：客户端 IndexedDB + 云端 PostgreSQL
- **同步**：GraphQL 订阅，实时同步
- **特点**：极快的响应速度

### 4. Supabase
- **架构**：客户端 PostgreSQL (WASM) + 云端 PostgreSQL
- **同步**：逻辑复制
- **特点**：完全相同的数据库

## 总结

**答案：是的，完全可以统一使用一个数据库或互相兼容的数据库！**

**最佳实践**：
1. **短期**：统一 Schema + 简单同步
2. **中期**：迁移到 RxDB
3. **长期**：使用 PostgreSQL + Electric SQL

**关键原则**：
- ✅ 使用相同或兼容的数据库引擎
- ✅ 统一 Schema 设计
- ✅ 使用成熟的同步协议
- ✅ 自动冲突解决
- ✅ 增量同步

**不要重复造轮子**：使用成熟的解决方案（PouchDB、RxDB、Electric SQL）而不是自己实现同步逻辑。

## 参考资源

- [Local-First Software](https://www.inkandswitch.com/local-first/) - 本地优先软件宣言
- [RxDB Documentation](https://rxdb.info/)
- [PouchDB Guide](https://pouchdb.com/guides/)
- [Electric SQL](https://electric-sql.com/)
- [PowerSync](https://www.powersync.com/)
- [WatermelonDB](https://watermelondb.dev/)

Content was rephrased for compliance with licensing restrictions.
