# 外键约束功能替代方案

## ❓ 问题：移除外键约束会丢失功能吗？

### 简单回答

✅ **是的，外键约束提供了重要的数据完整性保障**  
✅ **但我们会在应用层实现这些功能，不会丢失**

---

## 🔍 外键约束提供的功能

### 功能 1：引用完整性检查

**外键约束的作用**：
```sql
-- 有外键约束时
CREATE TABLE articles (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 插入数据时自动检查
INSERT INTO articles (user_id, title, content) 
VALUES (999, 'test', 'test');  
-- ❌ 如果 user_id=999 不存在于 users 表，数据库会拒绝插入
-- ERROR: insert or update on table "articles" violates foreign key constraint
```

**功能说明**：
- ✅ 防止插入无效的 user_id
- ✅ 保证每篇文章都有对应的用户
- ✅ 数据库层面自动验证

---

### 功能 2：级联删除（CASCADE）

**外键约束的作用**：
```sql
-- 有外键约束时
CREATE TABLE articles (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

-- 删除用户时自动删除相关文章
DELETE FROM users WHERE id = 1;
-- ✅ 数据库自动删除该用户的所有文章
-- DELETE FROM articles WHERE user_id = 1;  -- 自动执行
```

**功能说明**：
- ✅ 删除用户时自动清理相关数据
- ✅ 防止孤儿数据（orphan data）
- ✅ 保持数据一致性

---

### 功能 3：级联更新（ON UPDATE）

**外键约束的作用**：
```sql
-- 有外键约束时
CREATE TABLE articles (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON UPDATE CASCADE
);

-- 更新用户 ID 时自动更新相关文章
UPDATE users SET id = 100 WHERE id = 1;
-- ✅ 数据库自动更新所有文章的 user_id
-- UPDATE articles SET user_id = 100 WHERE user_id = 1;  -- 自动执行
```

**功能说明**：
- ✅ 更新主键时自动更新外键
- ✅ 保持引用一致性

---

### 功能 4：防止删除被引用的数据（RESTRICT）

**外键约束的作用**：
```sql
-- 有外键约束时
CREATE TABLE albums (
    id INTEGER PRIMARY KEY,
    name VARCHAR(255)
);

CREATE TABLE images (
    id INTEGER PRIMARY KEY,
    album_id INTEGER,
    FOREIGN KEY (album_id) REFERENCES albums(id) ON DELETE RESTRICT
);

-- 尝试删除有图片的相册
DELETE FROM albums WHERE id = 1;
-- ❌ 如果相册中有图片，数据库会拒绝删除
-- ERROR: update or delete on table "albums" violates foreign key constraint
```

**功能说明**：
- ✅ 防止误删除被引用的数据
- ✅ 保护数据完整性

---

## 🛠️ 迁移后如何保证这些功能？

### 方案：应用层实现 + 部分数据库约束

```
┌─────────────────────────────────────────────────────────────┐
│                    迁移前（服务器）                            │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  数据库层（PostgreSQL）                               │   │
│  │  ✅ 外键约束自动检查                                   │   │
│  │  ✅ 级联删除自动执行                                   │   │
│  │  ✅ 引用完整性自动保证                                 │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘

                          ↓ 迁移

┌─────────────────────────────────────────────────────────────┐
│                 迁移后（Windows 端）                          │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  应用层（TypeScript）                                  │   │
│  │  ✅ 手动检查 user_id（从 JWT 获取）                    │   │
│  │  ✅ 手动实现级联删除逻辑                               │   │
│  │  ✅ 手动验证引用完整性                                 │   │
│  └──────────────────────────────────────────────────────┘   │
│                          ↓                                   │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  数据库层（PostgreSQL）                               │   │
│  │  ✅ 保留表间外键约束（如 articles → topics）           │   │
│  │  ❌ 移除跨数据库外键（如 articles → users）            │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

---

## 📋 具体替代方案

### 1. user_id 引用完整性

#### 迁移前（数据库约束）

```sql
-- 数据库自动检查
CREATE TABLE articles (
    user_id INTEGER NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

INSERT INTO articles (user_id, ...) VALUES (999, ...);
-- ❌ 数据库拒绝：user_id=999 不存在
```

#### 迁移后（应用层检查）

```typescript
// Windows 端 - ArticleService.ts
class ArticleService {
  private userId: number;  // 从 JWT token 获取

  constructor() {
    // 登录时从服务器获取 user_id
    const token = localStorage.getItem('token');
    const decoded = jwt.decode(token);
    this.userId = decoded.userId;  // 例如：1
  }

  async createArticle(data: CreateArticleInput): Promise<Article> {
    // ✅ 应用层保证：所有文章都使用当前登录用户的 ID
    const article = {
      ...data,
      user_id: this.userId,  // 强制使用当前用户 ID
      created_at: new Date(),
      updated_at: new Date()
    };

    // 插入数据库
    const result = await this.db.query(
      'INSERT INTO articles (user_id, title, content, ...) VALUES ($1, $2, $3, ...)',
      [article.user_id, article.title, article.content, ...]
    );

    return result.rows[0];
  }

  async updateArticle(id: number, data: UpdateArticleInput): Promise<Article> {
    // ✅ 应用层保证：只能修改自己的文章
    const result = await this.db.query(
      'UPDATE articles SET title = $1, content = $2, updated_at = NOW() WHERE id = $3 AND user_id = $4',
      [data.title, data.content, id, this.userId]
    );

    if (result.rowCount === 0) {
      throw new Error('文章不存在或无权限修改');
    }

    return result.rows[0];
  }

  async deleteArticle(id: number): Promise<void> {
    // ✅ 应用层保证：只能删除自己的文章
    const result = await this.db.query(
      'DELETE FROM articles WHERE id = $1 AND user_id = $2',
      [id, this.userId]
    );

    if (result.rowCount === 0) {
      throw new Error('文章不存在或无权限删除');
    }
  }
}
```

**保证机制**：
- ✅ `user_id` 从 JWT token 获取（服务器签发，无法伪造）
- ✅ 所有操作都强制使用当前用户 ID
- ✅ 查询时添加 `WHERE user_id = $1` 条件
- ✅ 服务器 API 也会验证（双重保障）

---

### 2. 级联删除功能

#### 迁移前（数据库自动）

```sql
-- 数据库自动级联删除
CREATE TABLE articles (
    user_id INTEGER NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

DELETE FROM users WHERE id = 1;
-- ✅ 数据库自动删除该用户的所有文章
```

#### 迁移后（应用层实现）

```typescript
// Windows 端 - 用户注销功能
class UserService {
  async deleteAccount(): Promise<void> {
    const userId = this.getCurrentUserId();

    // ✅ 应用层实现级联删除
    await this.db.transaction(async (tx) => {
      // 1. 删除文章
      await tx.query('DELETE FROM articles WHERE user_id = $1', [userId]);
      
      // 2. 删除图片
      await tx.query('DELETE FROM images WHERE user_id = $1', [userId]);
      
      // 3. 删除知识库
      await tx.query('DELETE FROM knowledge_bases WHERE user_id = $1', [userId]);
      
      // 4. 删除平台账号
      await tx.query('DELETE FROM platform_accounts WHERE user_id = $1', [userId]);
      
      // 5. 删除发布任务
      await tx.query('DELETE FROM publishing_tasks WHERE user_id = $1', [userId]);
      
      // ... 其他表
      
      // 6. 通知服务器删除账号
      await apiClient.delete('/api/user/account');
    });
  }
}
```

**保证机制**：
- ✅ 使用数据库事务（transaction）保证原子性
- ✅ 按依赖顺序删除数据
- ✅ 删除失败时自动回滚
- ✅ 服务器端也会执行级联删除

**注意**：
- 实际上，Windows 端通常不会删除用户账号
- 用户账号管理在服务器端
- 这里只是举例说明如何实现级联删除

---

### 3. 表间外键约束（保留）

#### 迁移后（数据库约束保留）

```sql
-- ✅ 这些外键约束保留（引用的表也在 Windows 端）
CREATE TABLE articles (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,  -- ❌ 不设外键（users 表在服务器）
    distillation_id INTEGER,   -- ✅ 设外键（distillations 表在 Windows 端）
    topic_id INTEGER,          -- ✅ 设外键（topics 表在 Windows 端）
    image_id INTEGER,          -- ✅ 设外键（images 表在 Windows 端）
    
    -- ✅ 保留这些外键约束
    FOREIGN KEY (distillation_id) REFERENCES distillations(id) ON DELETE SET NULL,
    FOREIGN KEY (topic_id) REFERENCES topics(id) ON DELETE SET NULL,
    FOREIGN KEY (image_id) REFERENCES images(id) ON DELETE SET NULL
);

CREATE TABLE images (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,  -- ❌ 不设外键
    album_id INTEGER,          -- ✅ 设外键（albums 表在 Windows 端）
    
    -- ✅ 保留这个外键约束
    FOREIGN KEY (album_id) REFERENCES albums(id) ON DELETE SET NULL
);
```

**功能保留**：
- ✅ 删除蒸馏记录时，自动将文章的 `distillation_id` 设为 NULL
- ✅ 删除话题时，自动将文章的 `topic_id` 设为 NULL
- ✅ 删除图片时，自动将文章的 `image_id` 设为 NULL
- ✅ 删除相册时，自动将图片的 `album_id` 设为 NULL
- ✅ 数据库层面自动保证，无需应用层代码

---

### 4. task_id 引用（特殊处理）

#### 问题分析

```sql
-- 迁移前
CREATE TABLE articles (
    task_id INTEGER,
    FOREIGN KEY (task_id) REFERENCES generation_tasks(id)
);
```

- `generation_tasks` 表在服务器端（AI 生成任务队列）
- Windows 端不需要这个表
- 但 `task_id` 字段有历史数据

#### 迁移后（字段保留，外键移除）

```typescript
// Windows 端 - 创建文章时
class ArticleService {
  async saveGeneratedArticle(article: GeneratedArticle): Promise<Article> {
    // ✅ task_id 设为 NULL（不再引用服务器的 generation_tasks）
    const result = await this.db.query(
      `INSERT INTO articles (
        user_id, title, content, keyword, provider, 
        task_id,  -- 保留字段但设为 NULL
        created_at, updated_at
      ) VALUES ($1, $2, $3, $4, $5, NULL, NOW(), NOW())`,
      [this.userId, article.title, article.content, article.keyword, article.provider]
    );

    return result.rows[0];
  }
}
```

**处理方式**：
- ✅ 保留 `task_id` 字段（历史数据兼容）
- ✅ 新数据设为 NULL
- ✅ 不设外键约束
- ✅ 未来可能用于其他用途

---

## 🔒 数据完整性保证机制

### 多层保障

```
┌─────────────────────────────────────────────────────────────┐
│  第 1 层：前端验证                                             │
│  - 表单验证                                                   │
│  - 输入格式检查                                               │
│  - 用户权限检查                                               │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  第 2 层：应用层验证（Windows 端）                             │
│  - user_id 从 JWT 获取（无法伪造）                            │
│  - 所有操作添加 WHERE user_id = $1                           │
│  - 事务保证原子性                                             │
│  - 手动实现级联删除                                           │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  第 3 层：数据库约束（Windows 端）                             │
│  - 保留表间外键约束                                           │
│  - NOT NULL 约束                                             │
│  - UNIQUE 约束                                               │
│  - CHECK 约束                                                │
└─────────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────────┐
│  第 4 层：服务器验证（数据同步时）                             │
│  - JWT token 验证                                            │
│  - 用户权限验证                                               │
│  - 配额验证                                                   │
│  - 数据格式验证                                               │
└─────────────────────────────────────────────────────────────┘
```

---

## 📊 功能对比表

| 功能 | 迁移前（服务器） | 迁移后（Windows 端） | 是否丢失？ |
|------|-----------------|---------------------|-----------|
| **user_id 引用检查** | ✅ 数据库外键自动检查 | ✅ 应用层从 JWT 获取 | ❌ 未丢失 |
| **级联删除** | ✅ 数据库自动执行 | ✅ 应用层事务实现 | ❌ 未丢失 |
| **防止孤儿数据** | ✅ 数据库自动保证 | ✅ 应用层逻辑保证 | ❌ 未丢失 |
| **表间外键约束** | ✅ 数据库外键 | ✅ 数据库外键（保留） | ❌ 未丢失 |
| **引用完整性** | ✅ 数据库层面 | ✅ 应用层 + 数据库层面 | ❌ 未丢失 |
| **数据一致性** | ✅ 事务 + 外键 | ✅ 事务 + 应用逻辑 | ❌ 未丢失 |

---

## ⚠️ 需要注意的地方

### 1. 开发者责任增加

**迁移前**：
```typescript
// 数据库会自动检查，开发者不用担心
await db.query('INSERT INTO articles (user_id, ...) VALUES ($1, ...)', [999, ...]);
// ❌ 数据库自动拒绝
```

**迁移后**：
```typescript
// 开发者必须确保 user_id 正确
const userId = this.getCurrentUserId();  // 必须从 JWT 获取
await db.query('INSERT INTO articles (user_id, ...) VALUES ($1, ...)', [userId, ...]);
// ✅ 应用层保证正确性
```

**解决方案**：
- ✅ 封装 BaseService 类，统一处理 user_id
- ✅ 所有 Service 继承 BaseService
- ✅ 代码审查确保正确使用

---

### 2. 级联删除需要手动实现

**迁移前**：
```sql
-- 数据库自动处理
DELETE FROM users WHERE id = 1;
-- ✅ 自动删除相关数据
```

**迁移后**：
```typescript
// 必须手动实现
await db.transaction(async (tx) => {
  await tx.query('DELETE FROM articles WHERE user_id = $1', [userId]);
  await tx.query('DELETE FROM images WHERE user_id = $1', [userId]);
  // ... 其他表
});
```

**解决方案**：
- ✅ 创建统一的删除方法
- ✅ 使用事务保证原子性
- ✅ 编写单元测试验证

---

### 3. 数据迁移时需要清理

**问题**：
```sql
-- 迁移前的数据可能有无效引用
SELECT * FROM articles WHERE task_id IS NOT NULL;
-- 这些 task_id 引用服务器的 generation_tasks 表
```

**解决方案**：
```sql
-- 迁移时清理
UPDATE articles SET task_id = NULL;
```

---

## ✅ 总结

### 外键约束的功能不会丢失

| 功能 | 实现方式 | 保证程度 |
|------|---------|---------|
| **引用完整性** | 应用层从 JWT 获取 user_id | ✅ 强保证 |
| **级联删除** | 应用层事务实现 | ✅ 强保证 |
| **表间约束** | 数据库外键（保留） | ✅ 强保证 |
| **数据一致性** | 事务 + 应用逻辑 | ✅ 强保证 |

### 关键点

1. **user_id 引用**：
   - ❌ 不能依赖数据库外键（跨数据库）
   - ✅ 从 JWT token 获取（服务器签发，安全可靠）
   - ✅ 应用层强制使用当前用户 ID

2. **级联删除**：
   - ❌ 不能依赖数据库自动执行
   - ✅ 应用层手动实现
   - ✅ 使用事务保证原子性

3. **表间外键**：
   - ✅ 保留数据库外键约束
   - ✅ 功能完全不受影响

4. **多层保障**：
   - ✅ 前端验证
   - ✅ 应用层验证
   - ✅ 数据库约束
   - ✅ 服务器验证

### 最终结论

✅ **外键约束的功能不会丢失**  
✅ **通过应用层实现 + 部分数据库约束保证**  
✅ **甚至更安全（多层验证）**

---

**文档版本**: 1.0  
**创建日期**: 2026-01-16  
**目的**: 解释外键约束功能的替代方案

