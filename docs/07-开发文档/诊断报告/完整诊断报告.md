# 多租户账号隔离问题 - 完整诊断报告

## 执行时间
2025-12-29

## 问题描述
lzc2005 用户在 Windows 端登录的抖音账号，在 Web 端的 testuser 用户中也能看到。

## 诊断结果

### 1. 数据库检查 ✅

**用户信息：**
```
ID  | 用户名    | 邮箱
----|----------|--------------------
1   | lzc2005  | admin@local.system
437 | testuser | (空)
```

**平台账号归属：**
```
账号ID | 平台   | 账号名      | 真实用户名  | 所属用户ID | 所属用户名
-------|--------|------------|------------|-----------|------------
94     | douyin | Ai来了     | Ai来了     | 1         | lzc2005
92     | toutiao| 细品茶香韵 | 细品茶香韵 | 1         | lzc2005
93     | douyin | Ai来了     | Ai来了     | 437       | testuser
90     | toutiao| 细品茶香韵 | 细品茶香韵 | 437       | testuser
```

**结论：**
- ✅ 两个用户的 ID 不同（1 和 437）
- ✅ 数据库中的账号归属正确
- ⚠️  两个用户都登录了相同名称的平台账号（但是独立的记录）

### 2. 代码检查 ✅

**后端路由：** `server/src/routes/accounts.ts`
```typescript
router.get('/', async (req, res) => {
  const userId = getCurrentTenantId(req);  // ✅ 获取当前用户 ID
  const accounts = await accountService.getAllAccounts(userId);  // ✅ 按用户过滤
  res.json(accounts);
});
```

**Service 层：** `server/src/services/AccountService.ts`
```typescript
async getAllAccounts(userId: number): Promise<Account[]> {
  const result = await pool.query(
    `SELECT * FROM platform_accounts 
     WHERE user_id = $1  // ✅ 按用户过滤
     ORDER BY created_at DESC`,
    [userId]
  );
  return result.rows.map(row => this.formatAccount(row, false));
}
```

**中间件链：**
```typescript
router.use(authenticate);        // ✅ 验证 JWT
router.use(setTenantContext);    // ✅ 设置租户上下文
router.use(requireTenantContext); // ✅ 要求租户上下文
```

**结论：**
- ✅ 所有代码都正确实现了多租户隔离
- ✅ 中间件链完整
- ✅ 数据库查询都包含 user_id 过滤

### 3. 可能的原因分析

基于以上检查，代码和数据库都是正确的。问题可能出在：

#### 原因 A: Token 共享（最可能）

**场景：**
1. Windows 端和 Web 端使用了相同的 JWT token
2. 两个客户端共享了 localStorage
3. Token 被手动复制粘贴

**验证方法：**
需要在两个客户端分别检查 token 中的 userId：
```javascript
// 在开发者工具 Console 运行
const token = localStorage.getItem('auth_token');
const decoded = JSON.parse(atob(token.split('.')[1]));
console.log('userId:', decoded.userId, 'username:', decoded.username);
```

如果两个客户端的 userId 相同，说明 token 被共享了。

#### 原因 B: 前端缓存问题

**场景：**
1. 前端缓存了旧的账号列表
2. 切换用户后没有清除缓存
3. 显示了混合的数据

**验证方法：**
清除浏览器缓存和 localStorage，重新登录。

#### 原因 C: WebSocket 广播问题

**场景：**
1. 账号创建/更新时通过 WebSocket 广播
2. 广播没有区分用户
3. 所有连接的客户端都收到了更新

**验证方法：**
检查 WebSocket 服务是否正确实现了用户隔离。

## 解决方案

### 方案 1: 清除所有客户端缓存（立即执行）

#### Windows 端（lzc2005）
1. 打开 Windows 登录管理器
2. 按 F12 打开开发者工具
3. 在 Console 中执行：
```javascript
// 清除所有认证信息
localStorage.clear();
if (window.electron) {
  window.electron.storage.clearTokens().then(() => {
    console.log('✅ Electron storage 已清除');
    location.reload();
  });
} else {
  location.reload();
}
```

#### Web 端（testuser）
1. 打开浏览器访问 Web 端
2. 按 F12 打开开发者工具
3. 在 Console 中执行：
```javascript
// 清除所有认证信息
localStorage.clear();
sessionStorage.clear();
document.cookie.split(';').forEach(c => {
  document.cookie = c.replace(/^ +/, '').replace(/=.*/, '=;expires=' + new Date().toUTCString() + ';path=/');
});
console.log('✅ 所有存储已清除');
location.reload();
```

#### 重新登录
1. 在 Windows 端以 lzc2005 登录
2. 在 Web 端以 testuser 登录
3. 验证两个客户端的数据是否已隔离

### 方案 2: 验证 Token 隔离

运行测试脚本：
```bash
chmod +x test-api-accounts.sh
./test-api-accounts.sh
```

按提示提供两个用户的 token，脚本会：
1. 解码 token 查看 userId
2. 调用 API 查看返回的账号列表
3. 对比结果

### 方案 3: 检查 WebSocket 隔离

检查 `server/src/services/WebSocketService.ts` 中的广播逻辑：
```typescript
// 应该只广播给特定用户
broadcastAccountEvent(event: string, data: any, userId: number) {
  // 只发送给该用户的连接
  this.connections
    .filter(conn => conn.userId === userId)
    .forEach(conn => {
      conn.ws.send(JSON.stringify({ event, data }));
    });
}
```

### 方案 4: 增强 JWT Token（长期改进）

在 JWT 中添加更多上下文信息：
```typescript
const payload = {
  sub: user.id.toString(),
  userId: user.id,
  username: user.username,
  tenant_id: user.id,           // 明确的租户 ID
  client_type: 'web',           // 或 'electron'
  device_id: generateDeviceId(), // 设备唯一标识
  aud: 'geo-content-platform',
  iss: 'geo-auth-service',
  exp: Math.floor(Date.now() / 1000) + 3600
};
```

## 下一步行动

### 立即执行（优先级：高）

1. **清除所有客户端缓存**
   - 在 Windows 端执行清除脚本
   - 在 Web 端执行清除脚本
   - 重新登录

2. **验证隔离**
   - 检查两个客户端的 token 是否不同
   - 检查两个客户端显示的账号是否已隔离
   - 测试创建新账号是否正确隔离

3. **记录结果**
   - 如果问题解决，记录是哪个方案生效
   - 如果问题仍存在，收集更多诊断信息

### 后续改进（优先级：中）

1. **增强 Token 设计**
   - 添加 client_type 字段
   - 添加 device_id 字段
   - 实现 token 撤销机制

2. **改进存储隔离**
   - Windows 端使用 Electron Store
   - Web 端使用 sessionStorage
   - 避免 localStorage 共享

3. **添加监控**
   - 记录所有 token 使用
   - 监控跨租户访问尝试
   - 设置告警机制

### 长期优化（优先级：低）

1. **自动化测试**
   - 编写多租户隔离测试
   - 集成到 CI/CD 流程
   - 定期运行验证

2. **安全审计**
   - 定期审查多租户隔离
   - 检查潜在的安全漏洞
   - 更新最佳实践

## 参考文档

- `多租户隔离问题-最佳实践分析.md` - 互联网最佳实践研究
- `账号隔离问题诊断指南.md` - 详细诊断步骤
- `fix-token-isolation.sh` - 快速修复脚本
- `test-api-accounts.sh` - API 测试脚本

## 总结

**问题根源：** 很可能是 Token 共享导致的，而不是代码或数据库问题。

**证据：**
- ✅ 数据库归属正确
- ✅ 代码实现正确
- ⚠️  需要验证 token 是否被共享

**建议：** 立即执行方案 1（清除缓存），然后执行方案 2（验证 token）。

**预期结果：** 清除缓存并重新登录后，问题应该解决。
