# 本地发布架构重构方案

## 📋 需求说明

**目标**：将发布任务从服务器执行改为本地执行，服务器只负责数据存储和管理。

## 🎯 核心变化

### 当前架构（服务器执行）

```
前端 → API → 服务器 → 浏览器（服务器上）
```

### 目标架构（本地执行）

```
前端 → 本地执行器 → 浏览器（本地）
       ↓
       API（仅同步状态）
```

## 🏗️ 方案设计

### 方案 A：Electron 桌面应用（推荐）⭐

**架构图**：
```
┌─────────────────────────────────────────┐
│     Electron 主进程 (Node.js)            │
│  - 启动浏览器（Playwright）              │
│  - 执行发布任务                          │
│  - 管理任务队列                          │
└────────────┬────────────────────────────┘
             │
             ↓
┌─────────────────────────────────────────┐
│     Electron 渲染进程 (React)            │
│  - 任务管理界面                          │
│  - 实时日志显示                          │
│  - 状态监控                              │
└────────────┬────────────────────────────┘
             │
             ↓ HTTP API
┌─────────────────────────────────────────┐
│          服务器 (Express)                │
│  - 任务数据存储                          │
│  - 账号管理                              │
│  - 文章管理                              │
└─────────────────────────────────────────┘
```

**优势**：
- ✅ 完全本地执行，不依赖服务器
- ✅ 可以显示浏览器窗口
- ✅ 跨平台支持（Windows/macOS/Linux）
- ✅ 可以打包成独立应用
- ✅ 已有 Windows 登录管理器基础

**劣势**：
- ❌ 需要用户安装桌面应用
- ❌ 需要维护 Electron 应用
- ❌ 无法远程执行任务

### 方案 B：浏览器扩展（不推荐）

**架构图**：
```
浏览器扩展 → 内容脚本 → 页面操作
     ↓
   API（同步状态）
```

**优势**：
- ✅ 无需安装桌面应用
- ✅ 直接在浏览器中运行

**劣势**：
- ❌ 无法使用 Playwright（浏览器扩展限制）
- ❌ 需要重写所有平台适配器
- ❌ 功能受限（无法自动化登录等）
- ❌ 安全性问题

### 方案 C：混合模式（灵活）

**架构图**：
```
用户选择执行位置：
  - 本地执行 → Electron 应用
  - 服务器执行 → 原有架构
```

**优势**：
- ✅ 灵活性最高
- ✅ 向后兼容
- ✅ 适应不同场景

**劣势**：
- ❌ 需要维护两套代码
- ❌ 复杂度增加

## 🎯 推荐方案：Electron 桌面应用

### 实现步骤

#### 阶段 1：复用 Windows 登录管理器

**当前状态**：
- 已有 Electron 应用框架
- 已有前端 UI 组件
- 已有 API 客户端

**需要添加**：
1. 在主进程中集成 Playwright
2. 复制服务器的发布执行器代码
3. 复制平台适配器代码
4. 添加本地任务队列管理

#### 阶段 2：代码迁移

**需要迁移的文件**：

```
server/src/services/
├── PublishingExecutor.ts      → electron/services/
├── BrowserAutomationService.ts → electron/services/
├── adapters/
│   ├── PlatformAdapter.ts     → electron/services/adapters/
│   ├── XiaohongshuAdapter.ts  → electron/services/adapters/
│   ├── DouyinAdapter.ts       → electron/services/adapters/
│   └── ... (所有适配器)
└── TaskScheduler.ts           → electron/services/ (简化版)

server/src/config/
└── browserConfig.ts           → electron/config/
```

#### 阶段 3：架构调整

**主进程（electron/main/index.ts）**：
```typescript
import { app, BrowserWindow, ipcMain } from 'electron';
import { PublishingExecutor } from './services/PublishingExecutor';
import { TaskQueue } from './services/TaskQueue';

const publishingExecutor = new PublishingExecutor();
const taskQueue = new TaskQueue();

// 监听任务执行请求
ipcMain.handle('execute-task', async (event, taskId) => {
  try {
    // 从服务器获取任务详情
    const task = await fetchTaskFromServer(taskId);
    
    // 本地执行
    await publishingExecutor.executeTask(task);
    
    // 同步状态到服务器
    await updateTaskStatusOnServer(taskId, 'success');
    
    return { success: true };
  } catch (error) {
    await updateTaskStatusOnServer(taskId, 'failed', error.message);
    return { success: false, error: error.message };
  }
});

// 监听日志事件
publishingExecutor.on('log', (taskId, log) => {
  // 发送日志到渲染进程
  mainWindow.webContents.send('task-log', { taskId, log });
  
  // 同步日志到服务器（可选）
  syncLogToServer(taskId, log);
});
```

**渲染进程（React 组件）**：
```typescript
// 执行任务
const handleExecuteTask = async (taskId: number) => {
  try {
    // 调用主进程执行任务
    const result = await window.electron.executeTask(taskId);
    
    if (result.success) {
      message.success('任务执行成功');
    } else {
      message.error(`任务执行失败: ${result.error}`);
    }
  } catch (error) {
    message.error('任务执行失败');
  }
};

// 监听实时日志
useEffect(() => {
  const unsubscribe = window.electron.onTaskLog((data) => {
    if (data.taskId === currentTaskId) {
      setLogs(prev => [...prev, data.log]);
    }
  });
  
  return unsubscribe;
}, [currentTaskId]);
```

#### 阶段 4：服务器调整

**保留功能**：
- ✅ 任务数据存储（CRUD）
- ✅ 账号管理
- ✅ 文章管理
- ✅ 用户认证
- ✅ 日志存储（可选）

**移除功能**：
- ❌ 任务调度器（TaskScheduler）
- ❌ 发布执行器（PublishingExecutor）
- ❌ 浏览器自动化（BrowserAutomationService）
- ❌ 批次执行器（BatchExecutor）

**API 调整**：
```typescript
// 保留：创建任务
POST /api/publishing/tasks
// 返回任务 ID，但不执行

// 保留：获取任务详情
GET /api/publishing/tasks/:id

// 保留：更新任务状态（由客户端调用）
PUT /api/publishing/tasks/:id/status

// 移除：执行任务（不再需要）
// POST /api/publishing/tasks/:id/execute

// 新增：客户端同步日志
POST /api/publishing/tasks/:id/logs
```

## 📊 详细对比

| 功能 | 当前（服务器执行） | 目标（本地执行） |
|------|------------------|-----------------|
| 任务创建 | 前端 → 服务器 | 前端 → 服务器 |
| 任务执行 | 服务器自动 | 本地 Electron 应用 |
| 浏览器启动 | 服务器 | 本地 |
| 浏览器窗口 | 无法显示 | ✅ 可以显示 |
| 任务调度 | 服务器定时检查 | 本地任务队列 |
| 日志查看 | 实时流 | 本地实时 + 服务器存储 |
| 批量任务 | 服务器串行 | 本地队列管理 |
| 远程执行 | ✅ 支持 | ❌ 不支持 |
| 离线工作 | ❌ 不支持 | ✅ 支持（仅执行） |

## 🔧 技术实现细节

### 1. Electron 主进程集成 Playwright

```typescript
// electron/services/BrowserAutomationService.ts
import { chromium, Browser, Page } from 'playwright';

export class BrowserAutomationService {
  private browser: Browser | null = null;
  
  async launchBrowser(options: { headless?: boolean }) {
    // 在 Electron 主进程中启动浏览器
    this.browser = await chromium.launch({
      headless: options.headless ?? false, // 默认显示窗口
      executablePath: findChromeExecutable(),
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    });
    
    return this.browser;
  }
  
  // ... 其他方法
}
```

### 2. IPC 通信

```typescript
// electron/preload.ts
import { contextBridge, ipcRenderer } from 'electron';

contextBridge.exposeInMainWorld('electron', {
  // 执行任务
  executeTask: (taskId: number) => 
    ipcRenderer.invoke('execute-task', taskId),
  
  // 监听日志
  onTaskLog: (callback: (data: any) => void) => {
    ipcRenderer.on('task-log', (_, data) => callback(data));
    return () => ipcRenderer.removeAllListeners('task-log');
  },
  
  // 获取任务列表
  getTasks: () => 
    ipcRenderer.invoke('get-tasks'),
});
```

### 3. 本地任务队列

```typescript
// electron/services/TaskQueue.ts
export class TaskQueue {
  private queue: Task[] = [];
  private executing = false;
  
  async addTask(task: Task) {
    this.queue.push(task);
    if (!this.executing) {
      await this.processQueue();
    }
  }
  
  private async processQueue() {
    this.executing = true;
    
    while (this.queue.length > 0) {
      const task = this.queue.shift()!;
      
      try {
        await publishingExecutor.executeTask(task);
      } catch (error) {
        console.error(`任务 ${task.id} 执行失败:`, error);
      }
      
      // 任务间隔
      if (task.interval_minutes > 0) {
        await this.sleep(task.interval_minutes * 60 * 1000);
      }
    }
    
    this.executing = false;
  }
  
  private sleep(ms: number) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## ⚠️ 注意事项

### 1. 依赖安装

```json
// electron/package.json
{
  "dependencies": {
    "playwright": "^1.40.0",
    "electron": "^28.0.0"
  }
}
```

### 2. Playwright 浏览器下载

```bash
# 在 Electron 应用中需要手动下载浏览器
npx playwright install chromium
```

### 3. 打包配置

```json
// electron-builder.json
{
  "extraResources": [
    {
      "from": "node_modules/playwright/.local-browsers",
      "to": "playwright-browsers"
    }
  ]
}
```

### 4. 安全考虑

- 本地存储敏感信息（账号凭证）需要加密
- API Token 需要安全存储
- 防止 XSS 攻击（使用 contextBridge）

## 🚀 实施计划

### 第 1 周：基础框架

- [ ] 在 Windows 登录管理器中添加 Playwright 依赖
- [ ] 创建主进程服务目录结构
- [ ] 实现基础 IPC 通信

### 第 2 周：代码迁移

- [ ] 迁移 BrowserAutomationService
- [ ] 迁移 PublishingExecutor
- [ ] 迁移所有平台适配器

### 第 3 周：功能集成

- [ ] 实现本地任务队列
- [ ] 实现实时日志显示
- [ ] 实现状态同步到服务器

### 第 4 周：测试与优化

- [ ] 单平台测试
- [ ] 批量任务测试
- [ ] 性能优化
- [ ] 错误处理完善

### 第 5 周：服务器调整

- [ ] 移除服务器端执行代码
- [ ] 调整 API 接口
- [ ] 数据库迁移（如需要）

### 第 6 周：部署与文档

- [ ] 打包 Electron 应用
- [ ] 编写用户文档
- [ ] 部署服务器更新

## 📚 相关资源

- [Electron 文档](https://www.electronjs.org/docs)
- [Playwright 文档](https://playwright.dev/)
- [Electron + Playwright 集成示例](https://github.com/microsoft/playwright/issues/2347)

## 🎉 预期效果

实施后：
- ✅ 所有发布任务在本地执行
- ✅ 可以看到浏览器操作过程
- ✅ 服务器只负责数据管理
- ✅ 降低服务器资源消耗
- ✅ 提高任务执行灵活性

---

**下一步**：请确认是否采用此方案，我将开始详细实施。
