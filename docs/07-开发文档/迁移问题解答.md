# PostgreSQL 迁移常见问题解答

## ❓ 问题 1：66 个表只迁移 17 个？

### 快速回答

✅ **是的，49 个表不需要迁移**，因为它们是系统管理功能，必须保留在服务器。

### 详细解释

#### 为什么不是全部迁移？

```
服务器 PostgreSQL (66 个表)
├── 用户业务数据 (17 个) ────────┐
│   ├── articles (文章)          │
│   ├── albums (相册)            │  迁移到
│   ├── images (图片)            │  Windows 端
│   ├── knowledge_bases (知识库) │
│   └── ... (其他 13 个)         │
│                                ↓
└── 系统管理数据 (49 个) ────────┐
    ├── users (用户账号)         │
    ├── subscription_plans (套餐)│  保留在
    ├── orders (订单)            │  服务器
    ├── quota_configs (配额)     │
    └── ... (其他 45 个)         │
                                 ↓
```

#### 49 个表的分类

| 类别 | 表数 | 典型表名 | 为什么不迁移？ |
|------|------|---------|---------------|
| 用户认证 | 5 | users, user_sessions, refresh_tokens | 🔐 密码、会话必须在服务器管理 |
| 订阅支付 | 5 | subscription_plans, orders, user_subscriptions | 💰 支付、订阅必须在服务器管理 |
| 配额管理 | 6 | quota_configs, quota_reservations, user_usage | 📊 配额必须统一管理，防止篡改 |
| 权限安全 | 10 | permissions, security_config, security_events | 🔐 权限控制必须在服务器 |
| 审计日志 | 4 | audit_logs, admin_logs, auth_logs | 📝 审计必须在服务器，防止篡改 |
| 系统配置 | 6 | api_configs, platforms_config, config_history | ⚙️ 系统配置统一管理 |
| 代理商系统 | 2 | commission_records, profit_sharing_records | 💼 财务结算必须在服务器 |
| AI 生成管理 | 2 | generation_tasks, publish_analytics | 🤖 AI 任务队列在服务器 |
| 数据同步 | 2 | sync_snapshots, publish_records | 🔄 云端同步管理 |
| 存储管理 | 4 | storage_purchases, user_storage_usage | 💾 存储配额管理 |
| 其他 | 3 | adapter_versions, schema_migrations | 🔧 系统维护 |

#### 如果全部迁移会怎样？

❌ **安全问题**:
- 用户可以修改本地数据库，绕过配额限制
- 用户可以篡改订阅状态，免费使用
- 用户可以修改权限，获得管理员权限

❌ **数据一致性问题**:
- 多设备登录时，配额、订阅状态不一致
- 无法统一管理用户账号
- 无法进行系统审计

❌ **功能问题**:
- 支付功能无法工作（微信支付回调到服务器）
- AI 生成任务队列无法管理
- 数据同步无法实现

### 总结

```
┌─────────────────────────────────────────────────────────┐
│              Windows 端（本地 PostgreSQL）                │
│  ┌──────────────────────────────────────────────────┐   │
│  │  用户业务数据（17 个表）                           │   │
│  │  ✅ 文章、图库、知识库                             │   │
│  │  ✅ 平台账号（Cookie）                             │   │
│  │  ✅ 发布任务和记录                                 │   │
│  │  ✅ 离线可用、本地执行                             │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                          ↕️ API 调用
┌─────────────────────────────────────────────────────────┐
│              服务器端（PostgreSQL）                       │
│  ┌──────────────────────────────────────────────────┐   │
│  │  系统管理数据（49 个表）                           │   │
│  │  🔐 用户认证、权限控制                             │   │
│  │  💰 订阅支付、配额管理                             │   │
│  │  📝 审计日志、安全管理                             │   │
│  │  🤖 AI 生成、数据同步                              │   │
│  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────┘
```

**关键点**:
- ✅ 17 个表 = 用户的**内容**，需要离线访问
- ✅ 49 个表 = 系统的**管理**，必须服务器控制
- ✅ 两端通过 API 通信 = 安全 + 灵活

---

## ❓ 问题 2：18 个外键需要移除什么意思？

### 快速回答

✅ **服务器数据库现在就有这 18 个外键约束**，迁移时必须移除它们。

### 详细解释

#### 什么是外键约束？

外键约束是数据库的一种机制，确保引用的数据存在。

**例子**:
```sql
-- articles 表有一个外键约束
CREATE TABLE articles (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,
    title VARCHAR(500),
    ...
    CONSTRAINT articles_user_id_fkey 
        FOREIGN KEY (user_id) 
        REFERENCES users(id)  -- 引用 users 表
);
```

这个约束的作用：
- ✅ 插入文章时，检查 user_id 是否存在于 users 表
- ✅ 删除用户时，自动删除该用户的所有文章（CASCADE）
- ✅ 保证数据完整性

#### 服务器当前状态（迁移前）

```
服务器 PostgreSQL
┌─────────────────────────────────────────────────────────┐
│  articles 表                                             │
│  ┌────────────────────────────────────────────────┐     │
│  │ id: 1                                          │     │
│  │ user_id: 1 ──────────┐                        │     │
│  │ task_id: 1 ──────┐   │                        │     │
│  │ title: xxx       │   │                        │     │
│  └──────────────────┼───┼────────────────────────┘     │
│                     │   │                               │
│                     │   └──→ users 表                   │
│                     │       ┌──────────────────┐        │
│                     │       │ id: 1            │        │
│                     │       │ username: xxx    │        │
│                     │       └──────────────────┘        │
│                     │                                   │
│                     └──→ generation_tasks 表            │
│                         ┌──────────────────┐            │
│                         │ id: 1            │            │
│                         │ status: done     │            │
│                         └──────────────────┘            │
└─────────────────────────────────────────────────────────┘

✅ 外键约束正常工作（同一个数据库）
```

#### 迁移后的问题

```
Windows 端 PostgreSQL                服务器 PostgreSQL
┌─────────────────────┐             ┌─────────────────────┐
│  articles 表         │             │  users 表           │
│  ┌────────────────┐ │             │  ┌────────────────┐ │
│  │ id: 1          │ │             │  │ id: 1          │ │
│  │ user_id: 1 ────┼─┼─────❌────→ │  │ username: xxx  │ │
│  │ title: xxx     │ │  跨数据库    │  │ email: xxx     │ │
│  └────────────────┘ │  无法引用    │  └────────────────┘ │
└─────────────────────┘             └─────────────────────┘
                                    
                                    ┌─────────────────────┐
                                    │ generation_tasks 表  │
                                    │ ┌────────────────┐  │
                                    │ │ id: 1          │  │
                                    │ │ status: done   │  │
                                    │ └────────────────┘  │
                                    └─────────────────────┘

❌ 外键约束失败（跨数据库无法引用）
```

#### 18 个外键的详细清单

**17 个 user_id 外键**（每个迁移的表都有）:

| # | 表名 | 外键约束名 | 引用 | 现在有吗？ | 迁移后？ |
|---|------|-----------|------|----------|---------|
| 1 | articles | articles_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 2 | albums | albums_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 3 | images | images_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 4 | knowledge_bases | knowledge_bases_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 5 | knowledge_documents | knowledge_documents_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 6 | platform_accounts | platform_accounts_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 7 | publishing_tasks | publishing_tasks_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 8 | publishing_records | publishing_records_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 9 | publishing_logs | publishing_logs_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 10 | conversion_targets | conversion_targets_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 11 | distillations | distillations_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 12 | topics | topics_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 13 | article_settings | article_settings_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 14 | distillation_config | distillation_config_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 15 | image_usage | image_usage_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 16 | distillation_usage | distillation_usage_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |
| 17 | topic_usage | topic_usage_user_id_fkey | users(id) | ✅ 有 | ❌ 移除 |

**1 个 task_id 外键**:

| # | 表名 | 外键约束名 | 引用 | 现在有吗？ | 迁移后？ |
|---|------|-----------|------|----------|---------|
| 18 | articles | articles_task_id_fkey | generation_tasks(id) | ✅ 有 | ❌ 移除 |

#### 移除外键 ≠ 删除字段

**重要**: 移除外键约束，但**保留字段**！

**迁移前**（服务器）:
```sql
CREATE TABLE articles (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,  -- ✅ 字段存在
    task_id INTEGER,            -- ✅ 字段存在
    title VARCHAR(500),
    ...
    -- ✅ 外键约束存在
    CONSTRAINT articles_user_id_fkey 
        FOREIGN KEY (user_id) REFERENCES users(id),
    CONSTRAINT articles_task_id_fkey 
        FOREIGN KEY (task_id) REFERENCES generation_tasks(id)
);
```

**迁移后**（Windows 端）:
```sql
CREATE TABLE articles (
    id INTEGER PRIMARY KEY,
    user_id INTEGER NOT NULL,  -- ✅ 字段保留
    task_id INTEGER,            -- ✅ 字段保留
    title VARCHAR(500),
    ...
    -- ❌ 外键约束移除
    -- 不设置 user_id 和 task_id 的外键约束
);
```

#### 数据如何保证完整性？

**user_id**:
- ✅ 从 JWT token 获取（登录时服务器返回）
- ✅ 应用层验证（插入数据前检查）
- ✅ 服务器 API 验证（上传数据时检查）

**task_id**:
- ✅ 迁移时设为 NULL（因为 generation_tasks 表不迁移）
- ✅ 保留字段用于未来可能的用途

#### 保留的外键

**不是所有外键都移除**！表间关系的外键保留：

| 表名 | 外键列 | 引用表 | 迁移后？ |
|------|--------|--------|---------|
| articles | distillation_id | distillations | ✅ 保留 |
| articles | topic_id | topics | ✅ 保留 |
| articles | image_id | images | ✅ 保留 |
| images | album_id | albums | ✅ 保留 |
| knowledge_documents | knowledge_base_id | knowledge_bases | ✅ 保留 |
| topics | distillation_id | distillations | ✅ 保留 |
| ... | ... | ... | ... |

**为什么保留？**
- ✅ 引用的表也会迁移到 Windows 端
- ✅ 同一个数据库内，可以建立外键约束
- ✅ 保证数据完整性

### 总结

#### 问题 1：18 个外键需要移除什么意思？

| 问题 | 答案 |
|------|------|
| 这 18 个外键现在存在吗？ | ✅ 是的，服务器数据库现在就有 |
| 为什么要移除？ | ❌ 因为引用的表（users, generation_tasks）不迁移 |
| 字段也删除吗？ | ❌ 不删除，保留字段，只移除外键约束 |
| 数据完整性怎么办？ | ✅ 应用层保证（JWT、API 验证） |

#### 问题 2：之前就没有吗？

| 问题 | 答案 |
|------|------|
| 之前有这些外键吗？ | ✅ 有，服务器数据库现在就有 |
| 为什么说"移除"？ | ✅ 因为迁移后不能有（跨数据库） |
| 是新增的吗？ | ❌ 不是新增，是现有的需要移除 |

#### 操作步骤

```sql
-- 步骤 1: 导出服务器 schema（包含外键）
pg_dump ... > schema.sql

-- 步骤 2: 编辑 schema.sql，移除这 18 个外键约束
-- 删除这些行：
-- ALTER TABLE articles DROP CONSTRAINT articles_user_id_fkey;
-- ALTER TABLE articles DROP CONSTRAINT articles_task_id_fkey;
-- ... 其他 16 个

-- 步骤 3: 在 Windows 端创建表（不包含这 18 个外键）
psql -f schema.sql

-- 步骤 4: 导入数据
pg_dump --data-only ... > data.sql
psql -f data.sql
```

---

## ❓ 问题 3：移除外键约束会丢失功能吗？

### 快速回答

✅ **是的，外键约束提供了重要功能**，但我们会在应用层实现，不会丢失。

### 外键约束提供的功能

#### 1. 引用完整性检查

**有外键时**：
```sql
-- 数据库自动检查
INSERT INTO articles (user_id, title) VALUES (999, 'test');
-- ❌ 如果 user_id=999 不存在，数据库拒绝插入
```

**移除外键后**：
```typescript
// 应用层保证
class ArticleService {
  private userId: number;  // 从 JWT token 获取

  async createArticle(data) {
    // ✅ 强制使用当前登录用户的 ID
    await db.query(
      'INSERT INTO articles (user_id, title) VALUES ($1, $2)',
      [this.userId, data.title]  // 从 JWT 获取，无法伪造
    );
  }
}
```

#### 2. 级联删除（CASCADE）

**有外键时**：
```sql
-- 数据库自动级联删除
DELETE FROM users WHERE id = 1;
-- ✅ 自动删除该用户的所有文章
```

**移除外键后**：
```typescript
// 应用层实现
async deleteAccount() {
  await db.transaction(async (tx) => {
    // ✅ 手动实现级联删除
    await tx.query('DELETE FROM articles WHERE user_id = $1', [userId]);
    await tx.query('DELETE FROM images WHERE user_id = $1', [userId]);
    await tx.query('DELETE FROM knowledge_bases WHERE user_id = $1', [userId]);
    // ... 其他表
  });
}
```

#### 3. 防止删除被引用的数据（RESTRICT）

**有外键时**：
```sql
-- 数据库自动阻止
DELETE FROM albums WHERE id = 1;
-- ❌ 如果相册中有图片，数据库拒绝删除
```

**移除外键后**：
```typescript
// 应用层检查
async deleteAlbum(id: number) {
  // ✅ 手动检查是否有图片
  const imageCount = await db.query(
    'SELECT COUNT(*) FROM images WHERE album_id = $1',
    [id]
  );
  
  if (imageCount.rows[0].count > 0) {
    throw new Error('相册中还有图片，无法删除');
  }
  
  await db.query('DELETE FROM albums WHERE id = $1', [id]);
}
```

### 功能对比表

| 功能 | 迁移前（数据库） | 迁移后（应用层） | 是否丢失？ |
|------|----------------|----------------|-----------|
| 引用完整性检查 | ✅ 数据库自动 | ✅ 从 JWT 获取 | ❌ 未丢失 |
| 级联删除 | ✅ 数据库自动 | ✅ 事务实现 | ❌ 未丢失 |
| 防止孤儿数据 | ✅ 数据库自动 | ✅ 应用逻辑 | ❌ 未丢失 |
| 表间外键约束 | ✅ 数据库外键 | ✅ 数据库外键（保留） | ❌ 未丢失 |

### 多层保障机制

```
┌─────────────────────────────────────────────────────────┐
│  第 1 层：前端验证                                        │
│  - 表单验证、输入检查                                     │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  第 2 层：应用层验证（Windows 端）                        │
│  - user_id 从 JWT 获取（无法伪造）                       │
│  - 所有操作添加 WHERE user_id = $1                      │
│  - 事务保证原子性                                        │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  第 3 层：数据库约束（Windows 端）                        │
│  - 保留表间外键约束                                      │
│  - NOT NULL、UNIQUE、CHECK 约束                         │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│  第 4 层：服务器验证（数据同步时）                        │
│  - JWT token 验证、权限验证、配额验证                    │
└─────────────────────────────────────────────────────────┘
```

### 关键点

1. **user_id 引用**：
   - ✅ 从 JWT token 获取（服务器签发，安全可靠）
   - ✅ 应用层强制使用当前用户 ID
   - ✅ 所有查询添加 `WHERE user_id = $1`

2. **级联删除**：
   - ✅ 应用层手动实现
   - ✅ 使用事务保证原子性
   - ✅ 删除失败自动回滚

3. **表间外键**：
   - ✅ 保留数据库外键约束（如 articles → topics）
   - ✅ 功能完全不受影响

4. **多层保障**：
   - ✅ 前端 + 应用层 + 数据库 + 服务器
   - ✅ 甚至比单纯依赖数据库外键更安全

### 总结

✅ **外键约束的功能不会丢失**  
✅ **通过应用层实现 + 部分数据库约束保证**  
✅ **多层验证，更加安全可靠**

**详细说明**: 参见 [外键约束功能替代方案.md](./外键约束功能替代方案.md)

---

**文档版本**: 1.1  
**创建日期**: 2026-01-16  
**最后更新**: 2026-01-16  
**目的**: 解答用户关于迁移的常见疑问

