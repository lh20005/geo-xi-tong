# 端口安全详解

## 三种部署模式的安全性对比

### ❌ 模式 1：直接暴露（极度危险）

```
互联网 → 直接访问 → 服务器:5173
```

**问题：**
- 开发服务器直接暴露到公网
- Vite dev server 不是为生产环境设计的
- 没有 HTTPS 加密
- 没有限流保护
- 容易被扫描和攻击

**攻击示例：**
```bash
# 攻击者可以直接访问
curl http://你的服务器IP:5173
curl http://你的服务器IP:3000/api/users  # 如果没有认证，直接暴露数据
```

### ⚠️ 模式 2：改端口但仍直接暴露（依然危险）

```
互联网 → 直接访问 → 服务器:12345
```

**问题：**
- 改端口号只是"隐藏"，不是安全措施（Security by Obscurity）
- 端口扫描工具（nmap）几秒钟就能找到
- 本质问题没解决

**攻击示例：**
```bash
# 攻击者扫描所有端口
nmap -p 1-65535 你的服务器IP
# 发现 12345 端口开放，继续攻击
```

### ✅ 模式 3：反向代理 + 内网隔离（安全）

```
互联网 → 443端口(HTTPS) → Nginx → localhost:5173
                                  → localhost:3000
                                  → localhost:8080
```

**为什么安全：**

1. **网络层隔离**
   ```bash
   # 服务只监听 127.0.0.1（本地回环地址）
   # 外网物理上无法访问
   
   # 测试：从外网尝试访问
   curl http://你的服务器IP:5173
   # 结果：Connection refused（连接被拒绝）
   
   # 只有本机可以访问
   ssh 你的服务器
   curl http://localhost:5173
   # 结果：成功
   ```

2. **Nginx 作为安全网关**
   - SSL/TLS 加密
   - 限流保护
   - 请求过滤
   - 安全响应头
   - DDoS 防护

3. **多层防御**
   ```
   [防火墙] → [Nginx] → [应用认证] → [数据库权限]
   ```

## 是否需要更改端口号？

### 答案：不需要！

**原因：**

1. **端口号不是安全措施**
   - 5173 和 12345 在安全性上没有区别
   - 关键是监听地址（127.0.0.1 vs 0.0.0.0）

2. **Vite 默认配置已经安全**
   ```typescript
   // vite.config.ts
   export default defineConfig({
     server: {
       host: 'localhost',  // 只监听本地，安全 ✅
       port: 5173,
       // host: '0.0.0.0',  // 监听所有网卡，危险 ❌
     }
   })
   ```

3. **生产环境用户看不到内部端口**
   ```
   用户访问：https://app.yourdomain.com
   实际路径：443 → Nginx → localhost:5173
   
   用户完全不知道内部是 5173 还是其他端口
   ```

## 验证你的配置是否安全

### 检查清单

```bash
# 1. 检查服务监听地址
sudo netstat -tlnp | grep -E '3000|5173|8080'

# 安全的输出（只有 127.0.0.1）
tcp  0  0  127.0.0.1:3000   0.0.0.0:*   LISTEN  12345/node
tcp  0  0  127.0.0.1:5173   0.0.0.0:*   LISTEN  12346/node

# 不安全的输出（有 0.0.0.0）
tcp  0  0  0.0.0.0:3000     0.0.0.0:*   LISTEN  12345/node  ⚠️

# 2. 检查防火墙
sudo ufw status
# 应该只开放 22, 80, 443

# 3. 从外网测试（用手机4G网络或其他服务器）
curl http://你的服务器IP:5173
# 应该返回：Connection refused 或 timeout

# 4. 检查 Nginx 配置
sudo nginx -t
cat /etc/nginx/sites-enabled/geo-system
```

### 配置文件检查

```typescript
// ✅ 安全的 Vite 配置
// client/vite.config.ts
export default defineConfig({
  server: {
    host: 'localhost',  // 或 '127.0.0.1'
    port: 5173,
    strictPort: true,
  }
})

// ❌ 不安全的配置
export default defineConfig({
  server: {
    host: '0.0.0.0',  // 监听所有网卡
    port: 5173,
  }
})
```

```javascript
// ✅ 安全的 Express 配置
// server/src/index.ts
const PORT = process.env.PORT || 3000;
app.listen(PORT, 'localhost', () => {  // 指定 localhost
  console.log(`Server running on http://localhost:${PORT}`);
});

// ❌ 不安全的配置
app.listen(PORT, '0.0.0.0', () => {  // 监听所有网卡
  console.log(`Server running on port ${PORT}`);
});
```

## 实战测试

### 测试 1：验证内网隔离

```bash
# 在服务器上
npm run dev

# 在另一台电脑上（或手机4G网络）
curl http://服务器公网IP:5173
# 预期结果：Connection refused ✅

# 如果能访问，说明配置不安全 ❌
```

### 测试 2：验证反向代理

```bash
# 配置 Nginx 后
curl https://app.yourdomain.com
# 预期结果：返回页面内容 ✅

# 但直接访问内部端口
curl http://服务器公网IP:5173
# 预期结果：Connection refused ✅
```

## 常见误区

### 误区 1：改成非标准端口就安全了

```bash
# ❌ 错误想法
"我把 5173 改成 54321，黑客就找不到了"

# ✅ 现实
nmap -p- 你的服务器IP  # 扫描所有 65535 个端口
# 几分钟内就能找到所有开放端口
```

### 误区 2：内网端口号有讲究

```bash
# ❌ 错误想法
"5173 不安全，我要改成 8888"

# ✅ 现实
# 只要监听 127.0.0.1，用什么端口都一样安全
# 5173 和 8888 没有任何安全性差异
```

### 误区 3：开发端口可以直接用于生产

```bash
# ❌ 危险做法
npm run dev  # 在生产服务器上运行开发服务器

# ✅ 正确做法
npm run build  # 构建生产版本
# 通过 Nginx 提供静态文件
# 或使用 PM2 运行生产构建
```

## 推荐的生产配置

### 完整的安全配置

```nginx
# /etc/nginx/sites-available/geo-system

# HTTP 重定向到 HTTPS
server {
    listen 80;
    server_name app.yourdomain.com;
    return 301 https://$server_name$request_uri;
}

# HTTPS 主配置
server {
    listen 443 ssl http2;
    server_name app.yourdomain.com;
    
    # SSL 证书
    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;
    
    # SSL 安全配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;
    ssl_prefer_server_ciphers on;
    
    # 安全响应头
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    
    # 限流
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
    limit_req zone=api_limit burst=20 nodelay;
    
    # 静态文件（构建后的前端）
    location / {
        root /var/www/geo-system/client/dist;
        try_files $uri $uri/ /index.html;
        
        # 缓存策略
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
    
    # API 代理到内网 3000 端口
    location /api {
        proxy_pass http://127.0.0.1:3000;  # 注意：127.0.0.1，不是 0.0.0.0
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # 超时设置
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
    
    # WebSocket
    location /ws {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
        proxy_set_header Host $host;
    }
    
    # 禁止访问敏感文件
    location ~ /\. {
        deny all;
    }
    
    location ~ \.(env|sql|md)$ {
        deny all;
    }
}
```

### 防火墙配置

```bash
#!/bin/bash
# scripts/setup-firewall.sh

# 重置防火墙
sudo ufw --force reset

# 默认策略
sudo ufw default deny incoming
sudo ufw default allow outgoing

# 允许的端口
sudo ufw allow 22/tcp    # SSH
sudo ufw allow 80/tcp    # HTTP
sudo ufw allow 443/tcp   # HTTPS

# 可选：限制 SSH 访问（只允许特定 IP）
# sudo ufw allow from 你的办公室IP to any port 22

# 启用防火墙
sudo ufw --force enable

# 查看状态
sudo ufw status verbose

echo "✅ 防火墙配置完成"
echo "开放端口：22 (SSH), 80 (HTTP), 443 (HTTPS)"
echo "所有其他端口（包括 3000, 5173, 8080）已被防火墙阻止"
```

## 安全检查脚本

```bash
#!/bin/bash
# scripts/security-check.sh

echo "🔍 开始安全检查..."

# 1. 检查监听端口
echo -e "\n1️⃣ 检查服务监听地址："
netstat -tlnp 2>/dev/null | grep -E '3000|5173|8080' || ss -tlnp | grep -E '3000|5173|8080'

# 2. 检查防火墙
echo -e "\n2️⃣ 检查防火墙状态："
sudo ufw status

# 3. 检查 Nginx 配置
echo -e "\n3️⃣ 检查 Nginx 配置："
sudo nginx -t

# 4. 检查 SSL 证书
echo -e "\n4️⃣ 检查 SSL 证书："
sudo certbot certificates 2>/dev/null || echo "未安装 certbot"

# 5. 检查开放端口（从外部视角）
echo -e "\n5️⃣ 检查对外开放的端口："
sudo netstat -tlnp | grep LISTEN | grep -v '127.0.0.1'

# 6. 检查进程
echo -e "\n6️⃣ 检查运行的进程："
ps aux | grep -E 'node|nginx' | grep -v grep

echo -e "\n✅ 安全检查完成"
```

## 总结

### 关键要点

1. **端口号本身不提供安全性**
   - 5173 和任何其他端口在安全性上没有区别
   - 不需要更改端口号

2. **真正的安全来自：**
   - ✅ 监听地址（127.0.0.1 vs 0.0.0.0）
   - ✅ 防火墙配置
   - ✅ 反向代理（Nginx）
   - ✅ HTTPS 加密
   - ✅ 应用层认证和授权

3. **反向代理的安全原理：**
   - 内部服务只监听 localhost
   - 外网物理上无法直接访问内部端口
   - Nginx 作为唯一的公网入口，提供多层安全防护

4. **验证方法：**
   ```bash
   # 从外网测试（应该失败）
   curl http://服务器IP:5173  # Connection refused ✅
   
   # 通过 Nginx 访问（应该成功）
   curl https://app.yourdomain.com  # 返回页面 ✅
   ```

### 行动建议

- ✅ 保持 5173 端口不变
- ✅ 确保服务只监听 127.0.0.1
- ✅ 配置防火墙只开放 80/443
- ✅ 使用 Nginx 反向代理
- ✅ 启用 HTTPS
- ✅ 定期运行安全检查脚本
