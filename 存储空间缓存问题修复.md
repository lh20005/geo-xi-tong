# 存储空间缓存问题修复

## 问题描述
用户反馈：新建相册时可以上传图片，但再次上传时提示"存储空间不足"，实际上还有充足的空间。

## 问题分析

### 问题根源：Redis 缓存不一致

**场景重现**：
1. 用户第一次上传图片 → 成功
2. 存储使用量被记录到数据库
3. 缓存被清除
4. 用户第二次上传图片 → 失败（提示空间不足）

**原因**：
在检查配额时（`checkQuota`），系统从 Redis 缓存读取存储使用情况。但是：

1. **缓存时间窗口问题**：
   - 第一次上传后，虽然清除了缓存
   - 但在 `getUserStorageUsage` 被调用时，可能会重新缓存旧数据
   - 缓存 TTL 为 5 分钟

2. **读取顺序问题**：
   ```
   上传1 → 记录使用 → 清除缓存 → 成功
   上传2 → 检查配额 → 读取缓存（可能是旧数据）→ 失败
   ```

3. **缓存数据不准确**：
   - 缓存中的 `totalStorageBytes` 可能是 0
   - 实际数据库中已经有使用量
   - 导致计算错误：`0 + 新文件大小 > 配额` ❌

## 修复方案

### 方案：在配额检查时跳过缓存

**核心思路**：配额检查是关键操作，必须使用最新的数据库数据，不能依赖缓存。

### 1. StorageService.ts - 添加跳过缓存选项

**修改**：
```typescript
// 修改前
async getUserStorageUsage(userId: number): Promise<StorageUsage>

// 修改后
async getUserStorageUsage(userId: number, skipCache: boolean = false): Promise<StorageUsage>
```

**实现**：
```typescript
async getUserStorageUsage(userId: number, skipCache: boolean = false): Promise<StorageUsage> {
  try {
    const cacheKey = `storage:user:${userId}`;
    
    // 如果不跳过缓存，尝试从缓存读取
    if (!skipCache) {
      const cached = await redis.get(cacheKey);
      if (cached) {
        console.log(`[StorageService] 从缓存读取用户 ${userId} 存储数据`);
        return JSON.parse(cached);
      }
    } else {
      console.log(`[StorageService] 跳过缓存，直接从数据库读取用户 ${userId} 存储数据`);
    }
    
    // 从数据库读取最新数据
    // ...
  }
}
```

### 2. StorageQuotaService.ts - 配额检查时跳过缓存

**修改**：
```typescript
async checkQuota(userId: number, fileSizeBytes: number): Promise<QuotaCheckResult> {
  try {
    // 跳过缓存，直接从数据库读取最新数据
    const usage = await storageService.getUserStorageUsage(userId, true);
    
    // 确保类型转换正确
    const currentUsage = Number(usage.totalStorageBytes);
    const quotaBytes = Number(usage.storageQuotaBytes);
    const purchasedBytes = Number(usage.purchasedStorageBytes);
    const effectiveQuota = quotaBytes + purchasedBytes;
    
    // 详细日志
    console.log('[StorageQuotaService] 配额检查:', {
      userId,
      currentUsage,
      quotaBytes,
      purchasedBytes,
      effectiveQuota,
      fileSizeBytes
    });
    
    // 计算是否允许上传
    const afterUploadBytes = currentUsage + fileSizeBytes;
    const allowed = afterUploadBytes <= effectiveQuota;
    
    // ...
  }
}
```

## 修复效果

### 修复前
```
第一次上传：
  - 检查配额：缓存中使用量 = 0
  - 允许上传：0 + 5MB < 100MB ✅
  - 记录使用：数据库使用量 = 5MB
  - 清除缓存

第二次上传：
  - 检查配额：缓存中使用量 = 0（旧数据！）
  - 计算错误：0 + 5MB < 100MB ✅（但实际应该是 5MB + 5MB）
  - 或者缓存被某个其他请求更新，导致不一致
```

### 修复后
```
第一次上传：
  - 检查配额：跳过缓存，数据库使用量 = 0
  - 允许上传：0 + 5MB < 100MB ✅
  - 记录使用：数据库使用量 = 5MB

第二次上传：
  - 检查配额：跳过缓存，数据库使用量 = 5MB
  - 允许上传：5MB + 5MB < 100MB ✅
  - 记录使用：数据库使用量 = 10MB
```

## 日志输出

修复后，每次配额检查都会输出详细日志：

```
[StorageService] 跳过缓存，直接从数据库读取用户 437 存储数据
[StorageService] 用户存储使用: {
  userId: 437,
  totalStorageBytes: 5242880,
  storageQuotaBytes: 104857600,
  purchasedStorageBytes: 0,
  effectiveQuota: 104857600,
  rawTotal: '5242880',
  rawQuota: '104857600',
  totalType: 'string',
  quotaType: 'string'
}
[StorageQuotaService] 配额检查: {
  userId: 437,
  currentUsage: 5242880,
  quotaBytes: 104857600,
  purchasedBytes: 0,
  effectiveQuota: 104857600,
  fileSizeBytes: 1048576
}
[StorageQuotaService] 检查结果: {
  afterUploadBytes: 6291456,
  allowed: true,
  availableBytes: 99614720,
  needBytes: 1048576
}
```

## 测试验证

### 测试步骤
1. 登录系统
2. 进入"企业图库"
3. 创建新相册并上传第一张图片 → 应该成功
4. 在同一相册中上传第二张图片 → 应该成功
5. 继续上传多张图片 → 都应该成功
6. 查看后端日志，确认每次都跳过缓存

### 预期结果
- ✅ 第一次上传成功
- ✅ 第二次上传成功
- ✅ 后续上传都成功
- ✅ 日志显示"跳过缓存，直接从数据库读取"
- ✅ 存储使用量正确累加

## 性能考虑

### 缓存策略调整

**问题**：每次配额检查都跳过缓存，会增加数据库查询

**影响评估**：
- 配额检查只在上传时发生，频率不高
- 单次数据库查询性能影响可接受
- 数据准确性 > 性能优化

**未来优化**：
1. 使用 Redis 事务确保缓存一致性
2. 在记录存储使用时，同步更新缓存
3. 使用数据库触发器自动清除缓存

## 其他场景

### 缓存仍然有用的场景
- 仪表盘显示存储使用情况（可以容忍短暂延迟）
- 存储趋势图表（历史数据）
- 用户中心存储卡片（非关键操作）

### 必须跳过缓存的场景
- ✅ 配额检查（上传前）
- ✅ 购买存储空间后
- ✅ 管理员修改配额后
- ✅ 删除大量文件后

## 相关文件

- `server/src/services/StorageService.ts` - 添加 skipCache 参数
- `server/src/services/StorageQuotaService.ts` - 配额检查时跳过缓存

## 部署状态

✅ 代码已修复
✅ TypeScript 编译通过
✅ 后端服务已重启
✅ 服务运行正常

**后端服务**: http://localhost:3000

## 总结

这个问题的根本原因是**缓存一致性**问题。在分布式系统中，缓存和数据库的数据同步是一个经典难题。

**解决方案**：
- 对于关键操作（如配额检查），直接读取数据库
- 对于非关键操作（如展示），可以使用缓存
- 权衡性能和准确性

**经验教训**：
1. 缓存虽好，但要谨慎使用
2. 关键业务逻辑不应依赖缓存
3. 添加详细日志便于排查问题
4. 类型转换要格外小心（BIGINT → Number）

---

**修复时间**: 2026-01-04
**修复人**: Kiro AI Assistant
