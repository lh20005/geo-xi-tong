# 配额同步问题完整修复报告

## 问题描述

用户反馈：调整用户配额后，在生成文章页面仍显示配额不足，配额没有同步到所有应用点。

## 问题根源

通过系统诊断发现，**`check_user_quota` 数据库函数没有读取 `user_subscriptions.custom_quotas` 字段**，而是直接从 `plan_features` 表读取套餐默认配额。

### 诊断结果

```
custom_quotas 中的值: 6
check_user_quota 返回的值: 1
❌ 不一致！这就是问题所在！
```

## 修复方案

### 1. 修复 `check_user_quota` 函数 ✅

**迁移文件**: `server/src/db/migrations/032_fix_check_user_quota_to_use_custom_quotas.sql`

**核心改动**:
- 在函数中添加 `v_custom_quotas JSONB` 变量
- 从 `user_subscriptions` 表同时获取 `custom_quotas`
- **优先使用 `custom_quotas`**，如果不存在才使用 `plan_features`

```sql
-- 获取用户当前订阅和自定义配额
SELECT us.id, us.plan_id, us.custom_quotas 
INTO v_subscription_id, v_plan_id, v_custom_quotas
FROM user_subscriptions us
WHERE us.user_id = p_user_id 
  AND us.status = 'active'
  AND us.end_date > CURRENT_TIMESTAMP
ORDER BY us.end_date DESC
LIMIT 1;

-- 优先使用 custom_quotas（如果存在）
IF v_custom_quotas IS NOT NULL AND v_custom_quotas ? p_feature_code THEN
  v_feature_value := (v_custom_quotas->>p_feature_code)::INTEGER;
ELSE
  -- 如果没有自定义配额，从 plan_features 获取
  SELECT pf.feature_value INTO v_feature_value
  FROM plan_features pf
  WHERE pf.plan_id = v_plan_id AND pf.feature_code = p_feature_code;
END IF;
```

### 2. 创建配额同步服务 ✅

**文件**: `server/src/services/QuotaSyncService.ts`

**功能**:
1. **清除 Redis 缓存** - 删除所有配额相关的缓存
2. **同步存储配额** - 从 `custom_quotas` 同步到 `user_storage_usage`
3. **推送 WebSocket 通知** - 通知前端配额已更新
4. **刷新配额概览** - 预热缓存，确保下次查询使用新数据

**使用方法**:
```typescript
import { QuotaSyncService } from './QuotaSyncService';

// 在配额调整后调用
await QuotaSyncService.syncUserQuota(userId, '配额调整');
```

### 3. 集成到配额调整流程 ✅

**文件**: `server/src/services/UserSubscriptionManagementService.ts`

在 `adjustQuota` 方法的事务提交后，自动调用同步服务：

```typescript
await client.query('COMMIT');

// ... 发送 WebSocket 通知 ...

// 同步配额到所有系统
const { QuotaSyncService } = await import('./QuotaSyncService');
await QuotaSyncService.syncUserQuota(userId, `配额调整: ${featureCode}`);
```

## 修复验证

### 测试结果

```
步骤 1: 查看当前配额
  配额限制: 6
  当前使用: 2
  剩余: 4

步骤 2: 模拟配额调整（6 -> 10）
  ✅ 配额已调整为: 10

步骤 3: 调用同步服务
  [QuotaSync] 清除 Redis 缓存...
  [QuotaSync] 同步存储配额...
  [QuotaSync] 刷新配额概览...
  [QuotaSync] ✅ 用户配额同步完成

步骤 4: 验证同步结果
  配额限制: 10
  当前使用: 2
  剩余: 8
  ✅ 配额同步成功！

步骤 5: 模拟文章生成请求（需要 3 篇）
  ✅ 配额充足！可以生成文章
  需要: 3 篇
  剩余: 8 篇
```

## 涉及的配额检查点

### 后端 API

1. **文章生成** (`server/src/routes/articleGeneration.ts`)
   - ✅ 使用 `usageTrackingService.checkQuota()`
   - ✅ 调用 `check_user_quota` 函数

2. **发布文章** (`server/src/routes/publishing.ts`)
   - ✅ 使用 `usageTrackingService.checkQuota()`
   - ✅ 调用 `check_user_quota` 函数

3. **关键词蒸馏** (`server/src/routes/distillation.ts`)
   - ✅ 使用 `usageTrackingService.checkQuota()`
   - ✅ 调用 `check_user_quota` 函数

4. **存储空间** (`server/src/services/StorageQuotaService.ts`)
   - ✅ 使用 `get_user_storage_quota` 函数
   - ✅ 已有触发器自动同步

### 前端页面

1. **用户中心** (`client/src/pages/UserCenterPage.tsx`)
   - ✅ 监听 `quota_updated` WebSocket 事件
   - ✅ 监听 `storage_quota_changed` WebSocket 事件

2. **文章生成页面** (`client/src/pages/ArticleGenerationPage.tsx`)
   - ✅ 调用 `/api/article-generation/tasks` 时检查配额
   - ✅ 后端返回配额不足错误时显示提示

3. **图库上传** (`client/src/pages/AlbumDetailPage.tsx`)
   - ✅ 调用 `/api/storage/check-quota` 检查存储配额

## 配额同步流程图

```
管理员调整配额
    ↓
更新 user_subscriptions.custom_quotas
    ↓
调用 QuotaSyncService.syncUserQuota()
    ↓
┌─────────────────────────────────────┐
│ 1. 清除 Redis 缓存                   │
│    - user:X:subscription            │
│    - user:X:quotas                  │
│    - user:X:storage                 │
│    - storage:usage:X                │
├─────────────────────────────────────┤
│ 2. 同步存储配额                      │
│    custom_quotas.storage_space      │
│    → user_storage_usage             │
├─────────────────────────────────────┤
│ 3. 推送 WebSocket 通知               │
│    - quota_updated                  │
│    - storage_quota_changed          │
├─────────────────────────────────────┤
│ 4. 刷新配额概览                      │
│    预热所有 check_user_quota 查询    │
└─────────────────────────────────────┘
    ↓
前端接收通知并刷新显示
    ↓
用户下次操作时使用新配额
```

## 关键数据库函数

### 1. check_user_quota (已修复)

**用途**: 检查用户功能配额

**优先级**:
1. `user_subscriptions.custom_quotas` (最高优先级)
2. `plan_features.feature_value` (套餐默认值)
3. 硬编码默认值 (兜底)

### 2. get_user_storage_quota (已有)

**用途**: 获取用户存储配额

**优先级**:
1. `user_subscriptions.custom_quotas.storage_space`
2. `subscription_plans` 的默认存储配额

### 3. record_feature_usage (已有)

**用途**: 记录功能使用量

**触发**: 每次使用功能时调用

## 触发器

### trigger_sync_storage_quota (已有)

**表**: `user_subscriptions`

**触发时机**: `custom_quotas` 字段更新时

**作用**: 自动同步存储配额到 `user_storage_usage` 表

## 测试脚本

### 1. 诊断脚本
```bash
npx ts-node src/scripts/simple-quota-sync-check.ts
```

### 2. 配额检查测试
```bash
npx ts-node src/scripts/test-quota-check-after-adjustment.ts
```

### 3. 完整同步测试
```bash
npx ts-node src/scripts/test-complete-quota-sync.ts
```

## 部署步骤

### 1. 运行迁移
```bash
cd server
npx ts-node src/db/run-migration-032.ts
```

### 2. 验证修复
```bash
npx ts-node src/scripts/test-complete-quota-sync.ts
```

### 3. 重启服务
```bash
npm run server:dev
```

## 注意事项

1. **Redis 缓存**: 配额调整后会自动清除缓存，无需手动操作

2. **WebSocket 通知**: 需要 JWT_SECRET 环境变量，在生产环境中会正常工作

3. **存储配额**: 通过触发器自动同步，无需额外操作

4. **配额周期**: 配额重置基于订阅周期，不是固定日历周期

## 修复效果

✅ **配额调整立即生效** - 调整后无需等待或手动刷新

✅ **所有页面同步** - 文章生成、发布、蒸馏等所有功能都能正确检查配额

✅ **缓存自动清除** - 不会出现缓存导致的旧数据问题

✅ **实时通知** - 前端通过 WebSocket 实时接收配额更新

✅ **存储配额同步** - 存储空间配额自动同步到 user_storage_usage 表

## 相关文件

### 数据库迁移
- `server/src/db/migrations/032_fix_check_user_quota_to_use_custom_quotas.sql`
- `server/src/db/run-migration-032.ts`

### 服务层
- `server/src/services/QuotaSyncService.ts` (新增)
- `server/src/services/UserSubscriptionManagementService.ts` (已更新)
- `server/src/services/UsageTrackingService.ts` (已有)

### 测试脚本
- `server/src/scripts/simple-quota-sync-check.ts`
- `server/src/scripts/test-quota-check-after-adjustment.ts`
- `server/src/scripts/test-complete-quota-sync.ts`

## 总结

通过修复 `check_user_quota` 函数并创建配额同步服务，彻底解决了配额调整后不同步的问题。现在配额调整后会：

1. 立即更新数据库函数的返回值
2. 清除所有相关缓存
3. 同步存储配额
4. 推送实时通知
5. 在所有应用点生效

用户体验：**调整配额后，立即在文章生成页面看到新的配额限制，无需任何手动操作。**
