# 配额重置策略优化方案

## 问题分析

当前系统采用**固定日历周期**重置（每月1号），存在以下问题：

1. **不公平性**：1月5日购买和1月1日购买的用户，配额都在2月1日重置
2. **调整配额混乱**：管理员中途调整配额后，重置周期不明确
3. **升级时机敏感**：月底升级和月初升级体验差异大

## 推荐方案：按用户订阅周期重置

### 核心原则

**每个用户的配额重置周期独立计算，基于其订阅开始时间**

### 实现策略

#### 1. 月度配额（文章生成、发布次数等）

```
用户购买时间：2026-01-15
配额重置周期：每月15号 00:00

示例：
- 第1周期：2026-01-15 ~ 2026-02-14（31天）
- 第2周期：2026-02-15 ~ 2026-03-14（28天）
- 第3周期：2026-03-15 ~ 2026-04-14（31天）
```

**优点**：
- 公平：每个用户都有完整的30天使用周期
- 可预测：用户知道自己的重置日期
- 灵活：不受月份天数影响

#### 2. 订阅周期配额（平台账号、存储空间）

```
用户购买时间：2026-01-15
订阅时长：3个月
配额有效期：2026-01-15 ~ 2026-04-15

到期后：
- 自动降级到免费版
- 配额重置为免费版配额
```

**优点**：
- 明确：配额与订阅周期完全绑定
- 简单：到期即失效，续费即恢复

### 数据库设计

#### user_subscriptions 表增强

```sql
ALTER TABLE user_subscriptions
ADD COLUMN quota_reset_day INTEGER DEFAULT 1,  -- 配额重置日（1-28）
ADD COLUMN quota_reset_anchor TIMESTAMP;       -- 配额重置锚点时间

COMMENT ON COLUMN user_subscriptions.quota_reset_day IS '每月配额重置日（1-28，避免月末问题）';
COMMENT ON COLUMN user_subscriptions.quota_reset_anchor IS '配额重置锚点时间，用于计算下次重置';
```

#### user_usage 表调整

```sql
-- period_start 和 period_end 基于用户的重置周期
-- 示例：用户重置日为15号
-- period_start: 2026-01-15 00:00:00
-- period_end:   2026-02-14 23:59:59
```

### 核心函数重构

#### 1. 计算用户配额周期

```sql
CREATE OR REPLACE FUNCTION get_user_quota_period(
  p_user_id INTEGER,
  p_feature_code VARCHAR(50)
) RETURNS TABLE (
  period_start TIMESTAMP,
  period_end TIMESTAMP,
  reset_day INTEGER
) AS $$
DECLARE
  v_subscription_start TIMESTAMP;
  v_subscription_end TIMESTAMP;
  v_reset_day INTEGER;
  v_current_period_start TIMESTAMP;
  v_current_period_end TIMESTAMP;
BEGIN
  -- 获取用户订阅信息
  SELECT 
    us.start_date,
    us.end_date,
    EXTRACT(DAY FROM us.start_date)::INTEGER
  INTO v_subscription_start, v_subscription_end, v_reset_day
  FROM user_subscriptions us
  WHERE us.user_id = p_user_id 
    AND us.status = 'active'
    AND us.end_date > CURRENT_TIMESTAMP
  ORDER BY us.end_date DESC
  LIMIT 1;
  
  -- 如果没有有效订阅，返回NULL
  IF v_subscription_start IS NULL THEN
    RETURN;
  END IF;
  
  -- 限制重置日在1-28之间（避免月末问题）
  v_reset_day := LEAST(28, v_reset_day);
  
  -- 计算当前周期
  -- 如果当前日期 >= 重置日，则当前周期从本月重置日开始
  -- 否则从上月重置日开始
  IF EXTRACT(DAY FROM CURRENT_TIMESTAMP) >= v_reset_day THEN
    v_current_period_start := DATE_TRUNC('month', CURRENT_TIMESTAMP) + (v_reset_day - 1 || ' days')::INTERVAL;
  ELSE
    v_current_period_start := DATE_TRUNC('month', CURRENT_TIMESTAMP - INTERVAL '1 month') + (v_reset_day - 1 || ' days')::INTERVAL;
  END IF;
  
  -- 计算周期结束时间（下个重置日前一秒）
  v_current_period_end := v_current_period_start + INTERVAL '1 month' - INTERVAL '1 second';
  
  -- 确保不超过订阅结束时间
  IF v_current_period_end > v_subscription_end THEN
    v_current_period_end := v_subscription_end;
  END IF;
  
  -- 确保不早于订阅开始时间
  IF v_current_period_start < v_subscription_start THEN
    v_current_period_start := v_subscription_start;
  END IF;
  
  RETURN QUERY SELECT v_current_period_start, v_current_period_end, v_reset_day;
END;
$$ LANGUAGE plpgsql;
```

#### 2. 更新 record_feature_usage 函数

```sql
CREATE OR REPLACE FUNCTION record_feature_usage(
  p_user_id INTEGER,
  p_feature_code VARCHAR(50),
  p_amount INTEGER DEFAULT 1
) RETURNS BOOLEAN AS $$
DECLARE
  v_period RECORD;
BEGIN
  -- 获取用户配额周期
  SELECT * INTO v_period FROM get_user_quota_period(p_user_id, p_feature_code);
  
  IF v_period IS NULL THEN
    RAISE EXCEPTION '用户没有有效订阅';
  END IF;
  
  -- 记录使用量
  INSERT INTO user_usage (
    user_id, feature_code, usage_count, 
    period_start, period_end, last_reset_at
  )
  VALUES (
    p_user_id, p_feature_code, p_amount,
    v_period.period_start, v_period.period_end, v_period.period_start
  )
  ON CONFLICT (user_id, feature_code, period_start)
  DO UPDATE SET 
    usage_count = user_usage.usage_count + p_amount,
    updated_at = CURRENT_TIMESTAMP;
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

### 特殊场景处理

#### 1. 中途调整配额

```typescript
// 管理员调整配额时
async adjustUserQuota(
  userId: number, 
  featureCode: string, 
  newLimit: number
): Promise<void> {
  // 1. 更新 custom_quotas
  await pool.query(`
    UPDATE user_subscriptions
    SET custom_quotas = jsonb_set(
      COALESCE(custom_quotas, '{}'::jsonb),
      '{${featureCode}}',
      '${newLimit}'
    )
    WHERE user_id = $1 AND status = 'active'
  `, [userId]);
  
  // 2. 不重置使用量，保持当前周期
  // 用户在当前周期内立即享受新配额
  
  // 3. 记录调整历史
  await pool.query(`
    INSERT INTO subscription_adjustments (
      user_id, adjustment_type, feature_code, 
      old_value, new_value, reason
    ) VALUES ($1, 'quota_adjustment', $2, $3, $4, $5)
  `, [userId, featureCode, oldLimit, newLimit, reason]);
}
```

#### 2. 升级套餐

```typescript
// 用户升级套餐时
async upgradePlan(userId: number, newPlanId: number): Promise<void> {
  // 策略A：立即生效，重置配额周期（推荐）
  // - 优点：用户立即享受完整配额
  // - 缺点：可能损失部分旧周期
  
  await pool.query(`
    UPDATE user_subscriptions
    SET 
      plan_id = $1,
      start_date = CURRENT_TIMESTAMP,  -- 重置开始时间
      quota_reset_anchor = CURRENT_TIMESTAMP,
      updated_at = CURRENT_TIMESTAMP
    WHERE user_id = $2 AND status = 'active'
  `, [newPlanId, userId]);
  
  // 清除旧配额使用记录
  await pool.query(`
    DELETE FROM user_usage WHERE user_id = $1
  `, [userId]);
  
  // 策略B：保持周期，立即增加配额
  // - 优点：不损失旧周期
  // - 缺点：实现复杂
}
```

#### 3. 续费订阅

```typescript
// 用户续费时
async renewSubscription(userId: number, planId: number): Promise<void> {
  const currentSub = await this.getUserActiveSubscription(userId);
  
  if (currentSub && currentSub.end_date > new Date()) {
    // 情况1：提前续费（订阅未到期）
    // 延长结束时间，保持重置周期不变
    await pool.query(`
      UPDATE user_subscriptions
      SET 
        end_date = end_date + INTERVAL '1 month',
        updated_at = CURRENT_TIMESTAMP
      WHERE id = $1
    `, [currentSub.id]);
  } else {
    // 情况2：到期后续费
    // 创建新订阅，重新计算重置周期
    await pool.query(`
      INSERT INTO user_subscriptions (
        user_id, plan_id, status, 
        start_date, end_date, quota_reset_anchor
      ) VALUES (
        $1, $2, 'active',
        CURRENT_TIMESTAMP,
        CURRENT_TIMESTAMP + INTERVAL '1 month',
        CURRENT_TIMESTAMP
      )
    `, [userId, planId]);
  }
}
```

### 前端显示优化

```typescript
// 显示下次重置时间
interface QuotaInfo {
  feature_name: string;
  used: number;
  limit: number;
  reset_date: string;  // "2026-02-15 00:00:00"
  days_until_reset: number;  // 10
}

// 用户中心显示
<Card title="配额使用情况">
  <div>
    <span>每月生成文章数：{used} / {limit}</span>
    <span>重置时间：每月 {resetDay} 号</span>
    <span>距离重置：{daysUntilReset} 天</span>
  </div>
</Card>
```

## 实施步骤

### 第一阶段：数据库迁移

1. 添加 `quota_reset_day` 和 `quota_reset_anchor` 字段
2. 为现有用户初始化重置日（基于 start_date）
3. 创建 `get_user_quota_period` 函数

### 第二阶段：核心函数重构

1. 更新 `record_feature_usage` 函数
2. 更新 `check_feature_quota` 函数
3. 更新 `get_user_usage_stats` 函数

### 第三阶段：服务层适配

1. 更新 `SubscriptionService`
2. 更新 `UserSubscriptionManagementService`
3. 添加配额周期查询 API

### 第四阶段：前端展示

1. 显示个性化重置时间
2. 添加重置倒计时
3. 优化配额使用提示

## 兼容性考虑

### 过渡方案

对于已有用户，可以提供两种模式：

1. **保持原有模式**（月初重置）
   - `quota_reset_day = 1`
   - 不影响现有用户体验

2. **迁移到新模式**（订阅日重置）
   - 在下次续费时自动切换
   - 或提供手动切换选项

### 配置开关

```typescript
// config/features.ts
export const QUOTA_RESET_MODE = {
  CALENDAR_MONTH: 'calendar',  // 日历月模式（月初重置）
  SUBSCRIPTION_CYCLE: 'cycle'  // 订阅周期模式（订阅日重置）
};

// 允许系统级配置
const QUOTA_MODE = process.env.QUOTA_RESET_MODE || 'cycle';
```

## 总结

### 推荐采用：订阅周期重置模式

**优点**：
- ✅ 公平：每个用户都有完整使用周期
- ✅ 灵活：支持中途调整配额
- ✅ 可预测：用户清楚自己的重置时间
- ✅ 合理：升级/续费逻辑清晰

**缺点**：
- ❌ 实现复杂度略高
- ❌ 需要迁移现有数据
- ❌ 运营统计需要调整（不能按自然月统计）

### 建议

1. **新系统**：直接采用订阅周期模式
2. **现有系统**：提供配置开关，逐步迁移
3. **混合模式**：允许管理员为特定用户设置重置模式

---

**下一步行动**：
1. 确认采用哪种模式
2. 评估迁移影响
3. 制定详细实施计划
