# 本地发布数据流 - 可视化指南

## 🎯 核心问题回答

### Q1: 发布任务时选择的数据，需要去服务器调取？
**答案：是的** ✅

### Q2: 发布成功后的数据反馈再传回到服务器？
**答案：是的** ✅

---

## 📊 完整数据流图

```
┌─────────────────────────────────────────────────────────────┐
│                    阶段 1：任务创建                          │
└─────────────────────────────────────────────────────────────┘

用户在 Electron 应用中：
  1. 选择文章（从服务器获取列表）
  2. 选择账号（从服务器获取列表）
  3. 配置参数（本地输入）
  
  ↓
  
Electron 渲染进程 → 服务器 API
  POST /api/publishing/tasks
  {
    article_id: 123,
    account_id: 456,
    platform_id: "xiaohongshu",
    config: { headless: false }
  }
  
  ↓
  
服务器：
  - 保存任务到数据库
  - 状态：pending
  - 返回任务 ID: 789

┌─────────────────────────────────────────────────────────────┐
│                    阶段 2：任务执行                          │
└─────────────────────────────────────────────────────────────┘

用户点击"执行任务"
  ↓
Electron 主进程：
  
  Step 1: 获取任务详情
    GET /api/publishing/tasks/789?include=article,account
    ↓
    服务器返回：
    {
      id: 789,
      article: {
        title: "文章标题",
        content: "文章内容...",
        image_url: "/uploads/xxx.jpg"
      },
      account: {
        account_name: "测试账号",
        credentials: {
          cookies: [...]  // 登录凭证
        }
      }
    }
  
  Step 2: 更新状态为执行中
    PUT /api/publishing/tasks/789/status
    { status: "running", started_at: "2024-01-20T10:00:00Z" }
  
  Step 3: 执行发布（本地）
    - 启动浏览器
    - 使用 credentials 登录
    - 使用 article 数据发布
    - 实时发送日志到渲染进程
  
  Step 4: 同步日志（可选）
    POST /api/publishing/tasks/789/logs
    { level: "info", message: "开始登录..." }
  
  Step 5: 更新状态为成功
    PUT /api/publishing/tasks/789/status
    { status: "success", completed_at: "2024-01-20T10:05:00Z" }

┌─────────────────────────────────────────────────────────────┐
│                    阶段 3：结果同步                          │
└─────────────────────────────────────────────────────────────┘

Electron 主进程 → 服务器：
  POST /api/publishing/records
  {
    task_id: 789,
    article_id: 123,
    platform_id: "xiaohongshu",
    published_at: "2024-01-20T10:05:00Z",
    article_title: "文章标题",
    article_content: "文章内容..."
  }
  
  ↓
  
服务器：
  - 创建发布记录
  - 保存文章快照
  - 返回成功
```

---

## 🔄 数据流向总结

### 从服务器获取的数据

| 数据类型 | API 端点 | 用途 |
|---------|---------|------|
| 文章列表 | GET /api/articles | 用户选择要发布的文章 |
| 账号列表 | GET /api/accounts | 用户选择发布账号 |
| 平台列表 | GET /api/platforms | 显示支持的平台 |
| 任务详情 | GET /api/publishing/tasks/:id | 执行任务时获取完整数据 |
| 文章内容 | 包含在任务详情中 | 发布时使用 |
| 账号凭证 | 包含在任务详情中 | 登录时使用 |

### 同步到服务器的数据

| 数据类型 | API 端点 | 时机 |
|---------|---------|------|
| 任务创建 | POST /api/publishing/tasks | 用户创建任务时 |
| 任务状态 | PUT /api/publishing/tasks/:id/status | 执行开始/结束时 |
| 任务日志 | POST /api/publishing/tasks/:id/logs | 执行过程中（可选） |
| 发布记录 | POST /api/publishing/records | 发布成功后 |

---

## 💻 代码示例

### 1. 创建任务

```typescript
// Electron 渲染进程
const createTask = async () => {
  const response = await apiClient.post('/publishing/tasks', {
    article_id: selectedArticle.id,
    account_id: selectedAccount.id,
    platform_id: selectedAccount.platform_id,
    config: {
      headless: false,
      timeout_minutes: 15
    }
  });
  
  const taskId = response.data.data.id;
  message.success(`任务已创建: #${taskId}`);
};
```

### 2. 执行任务

```typescript
// Electron 主进程
const executeTask = async (taskId: number) => {
  // 1. 获取任务详情（含文章和账号）
  const task = await apiClient.get(
    `/publishing/tasks/${taskId}?include=article,account`
  );
  
  // 2. 更新状态
  await apiClient.put(`/publishing/tasks/${taskId}/status`, {
    status: 'running',
    started_at: new Date().toISOString()
  });
  
  // 3. 执行发布（使用 task.data.article 和 task.data.account）
  await publishingExecutor.execute(task.data);
  
  // 4. 更新状态
  await apiClient.put(`/publishing/tasks/${taskId}/status`, {
    status: 'success',
    completed_at: new Date().toISOString()
  });
  
  // 5. 创建发布记录
  await apiClient.post('/publishing/records', {
    task_id: taskId,
    article_id: task.data.article_id,
    published_at: new Date().toISOString(),
    article_title: task.data.article.title
  });
};
```

### 3. 实时日志

```typescript
// Electron 主进程 → 渲染进程
mainWindow.webContents.send('task-log', {
  taskId: 789,
  level: 'info',
  message: '🔐 开始登录...'
});

// Electron 主进程 → 服务器（可选）
await apiClient.post(`/publishing/tasks/${taskId}/logs`, {
  level: 'info',
  message: '🔐 开始登录...'
});
```

---

## 🎯 关键设计原则

### 1. 服务器是唯一数据源

```
❌ 错误：本地缓存文章内容
✅ 正确：每次执行时从服务器获取最新数据
```

**原因**：
- 文章可能被修改
- 账号凭证可能更新
- 确保数据一致性

### 2. 本地只负责执行

```
Electron 的职责：
  ✅ 启动浏览器
  ✅ 执行发布流程
  ✅ 显示实时日志
  
  ❌ 不存储业务数据
  ❌ 不做数据管理
```

### 3. 状态实时同步

```
执行过程中的每个关键节点都同步到服务器：
  - 开始执行 → running
  - 执行成功 → success
  - 执行失败 → failed
```

**好处**：
- 用户可以在任何设备查看任务状态
- 服务器有完整的执行记录
- 便于问题排查

---

## 📊 数据量评估

### 单次任务执行的数据传输

| 阶段 | 方向 | 数据量 | 说明 |
|------|------|--------|------|
| 获取任务详情 | 服务器 → 本地 | ~50KB | 文章内容 + 账号凭证 |
| 更新状态（3次） | 本地 → 服务器 | ~1KB | 状态更新 |
| 同步日志（10条） | 本地 → 服务器 | ~5KB | 可选 |
| 创建发布记录 | 本地 → 服务器 | ~50KB | 文章快照 |
| **总计** | - | **~106KB** | 单次任务 |

### 批量任务（10篇文章 × 3个平台 = 30个任务）

- 总数据量：~3.2MB
- 执行时间：~30分钟（每个任务1分钟）
- 平均带宽：~1.8KB/s

**结论**：数据量很小，网络不是瓶颈 ✅

---

## ⚡ 性能优化建议

### 1. 批量获取

```typescript
// ❌ 低效：逐个获取
for (const taskId of taskIds) {
  const task = await apiClient.get(`/tasks/${taskId}`);
}

// ✅ 高效：批量获取
const tasks = await apiClient.get('/tasks', {
  params: { ids: taskIds.join(',') }
});
```

### 2. 本地缓存不变数据

```typescript
// 平台列表（很少变化）
const platforms = await cacheService.get('platforms', async () => {
  const response = await apiClient.get('/platforms');
  return response.data.data;
}, 3600000); // 缓存1小时
```

### 3. 增量同步日志

```typescript
// 只获取新日志
const newLogs = await apiClient.get(`/tasks/${taskId}/logs`, {
  params: { since: lastLogId }
});
```

---

## 🎉 总结

### 数据流特点

1. **服务器中心化**：所有数据存储在服务器
2. **本地执行化**：任务执行在本地 Electron
3. **实时同步化**：状态和日志实时同步

### 实施步骤

1. ✅ 实现 API 端点（服务器）
2. ✅ 实现数据获取（Electron）
3. ✅ 实现任务执行（Electron）
4. ✅ 实现状态同步（Electron → 服务器）
5. ✅ 实现日志同步（可选）

### 预期效果

- ✅ 数据始终最新
- ✅ 服务器负担降低 80%
- ✅ 用户体验提升（可视化）
- ✅ 系统架构清晰

---

**完整技术文档**：`docs/07-开发文档/本地发布数据流设计.md`

**下一步**：开始实施代码迁移 🚀
