# 自动同步测试方案

**测试目标**: 验证服务器生成文章后能否立即同步到 Windows 本地数据库

**测试时间**: 2026-01-20

---

## 测试准备

### 1. 重新构建代码（包含详细日志）

```bash
cd windows-login-manager
npm run build
```

### 2. 启动 Windows 应用

```bash
npm run dev
```

### 3. 打开浏览器控制台

在 Windows 应用中按 `Cmd+Option+I` (macOS) 或 `Ctrl+Shift+I` (Windows) 打开开发者工具。

---

## 测试步骤

### 步骤 1: 记录初始状态

**本地数据库**:
```bash
psql -U lzc -d geo_windows -c "SELECT COUNT(*) as total, MAX(created_at) as latest FROM articles WHERE user_id = 1;"
```

**服务器数据库**:
```bash
ssh ubuntu@124.221.247.107 "sudo -u postgres psql -d geo_system -c 'SELECT COUNT(*) as total, MAX(created_at) as latest FROM articles WHERE user_id = 1;'"
```

**记录结果**:
- 本地文章数: ___
- 服务器文章数: ___
- 最新文章时间: ___

### 步骤 2: 生成新文章

1. 在 Windows 应用中打开"文章生成"页面
2. 点击"新建任务"
3. 配置参数：
   - 蒸馏结果: 选择任意一个
   - 图库: 选择任意一个
   - 知识库: 选择任意一个
   - 文章设置: 选择任意一个
   - 生成数量: 1
4. 点击"提交"

**记录任务 ID**: ___

### 步骤 3: 监控同步过程

**在浏览器控制台中观察日志**:

预期看到的日志：
```
[自动同步 HH:MM:SS] 开始同步检查
[自动同步 HH:MM:SS] - 总任务数: X
[自动同步 HH:MM:SS] - 可同步任务数: Y
[自动同步 HH:MM:SS] 可同步任务列表: [...]
[自动同步 HH:MM:SS] 用户 ID: 1
[自动同步 HH:MM:SS] [任务 XX] 开始处理
[自动同步 HH:MM:SS] [任务 XX] 正在获取任务详情...
[自动同步 HH:MM:SS] [任务 XX] 任务详情获取成功
[自动同步 HH:MM:SS] [任务 XX] - 文章列表长度: 1
[自动同步 HH:MM:SS] [任务 XX] [文章 YY] 开始处理: [标题]
[自动同步 HH:MM:SS] [任务 XX] [文章 YY] 检查文章是否已存在...
[自动同步 HH:MM:SS] [任务 XX] [文章 YY] 检查结果: {...}
[自动同步 HH:MM:SS] [任务 XX] [文章 YY] 文章不存在，开始同步
[自动同步 HH:MM:SS] [任务 XX] [文章 YY] 正在获取文章完整内容...
[自动同步 HH:MM:SS] [任务 XX] [文章 YY] 文章内容获取成功，长度: XXXX 字符
[自动同步 HH:MM:SS] [任务 XX] [文章 YY] 正在保存到本地数据库...
[自动同步 HH:MM:SS] [任务 XX] [文章 YY] ✅ 同步成功
[自动同步 HH:MM:SS] 同步完成
[自动同步 HH:MM:SS] - 耗时: XXXms
[自动同步 HH:MM:SS] - 新增: 1 篇
[自动同步 HH:MM:SS] - 跳过: 0 篇
[自动同步 HH:MM:SS] - 失败: 0 篇
```

**记录实际日志**: （复制粘贴控制台日志）

### 步骤 4: 验证同步结果

**等待时间**: 文章生成完成后等待 10 秒

**检查本地数据库**:
```bash
psql -U lzc -d geo_windows -c "SELECT id, title, task_id, created_at FROM articles WHERE user_id = 1 ORDER BY created_at DESC LIMIT 1;"
```

**检查服务器数据库**:
```bash
ssh ubuntu@124.221.247.107 "sudo -u postgres psql -d geo_system -c 'SELECT id, title, task_id, created_at FROM articles WHERE user_id = 1 ORDER BY created_at DESC LIMIT 1;'"
```

**对比结果**:
- 本地最新文章: ___
- 服务器最新文章: ___
- 是否一致: ___

### 步骤 5: 检查文章管理页面

1. 在 Windows 应用中打开"文章管理"页面
2. 刷新页面
3. 检查新文章是否显示

**结果**: ___

---

## 测试场景

### 场景 1: 正常同步（基础测试）

**步骤**:
1. 生成 1 篇文章
2. 等待任务完成
3. 观察控制台日志
4. 验证文章是否同步

**预期结果**:
- ✅ 控制台显示完整的同步日志
- ✅ 文章在 2-10 秒内同步到本地
- ✅ 文章管理页面显示新文章

**实际结果**: ___

### 场景 2: 多篇文章同步

**步骤**:
1. 生成 3 篇文章
2. 等待任务完成
3. 观察控制台日志
4. 验证所有文章是否同步

**预期结果**:
- ✅ 控制台显示 3 篇文章的同步日志
- ✅ 所有文章都成功同步
- ✅ 文章管理页面显示 3 篇新文章

**实际结果**: ___

### 场景 3: 页面刷新后同步

**步骤**:
1. 生成 1 篇文章
2. 在任务完成前刷新页面
3. 等待页面重新加载
4. 观察控制台日志
5. 验证文章是否同步

**预期结果**:
- ✅ 页面刷新后自动检测到未同步的文章
- ✅ 文章成功同步
- ✅ 控制台显示同步日志

**实际结果**: ___

### 场景 4: 运行中任务的部分同步

**步骤**:
1. 生成 5 篇文章
2. 在第 2 篇生成完成时观察日志
3. 验证已生成的文章是否同步

**预期结果**:
- ✅ 已生成的文章立即同步
- ✅ 未生成的文章不会同步
- ✅ 控制台显示部分同步日志

**实际结果**: ___

---

## 日志分析

### 关键日志点

| 日志内容 | 说明 | 预期 |
|---------|------|------|
| `开始同步检查` | 同步流程启动 | 每 2-10 秒出现一次 |
| `可同步任务数: X` | 检测到可同步的任务 | X > 0 表示有任务需要同步 |
| `正在获取任务详情...` | 调用 API 获取任务详情 | 应该成功 |
| `文章列表长度: X` | 任务包含的文章数量 | X > 0 表示有文章 |
| `检查文章是否已存在...` | 检查本地数据库 | 应该返回 false（不存在） |
| `正在获取文章完整内容...` | 调用 API 获取文章内容 | 应该成功 |
| `正在保存到本地数据库...` | 保存到本地 | 应该成功 |
| `✅ 同步成功` | 单篇文章同步成功 | 每篇文章都应该成功 |
| `同步完成` | 整个同步流程完成 | 显示统计信息 |

### 异常日志

| 日志内容 | 可能原因 | 解决方案 |
|---------|---------|---------|
| `跳过：非 Electron 环境` | 不在 Electron 中运行 | 使用 `npm run dev` 启动 |
| `无法获取用户 ID` | 用户未登录 | 重新登录 |
| `文章列表为空，跳过` | 服务器端未返回文章列表 | 检查服务器端接口 |
| `文章已存在，跳过` | 文章已经同步过 | 正常，不需要处理 |
| `❌ 同步异常` | 同步过程出错 | 查看详细错误信息 |
| `❌ 获取任务详情失败` | API 调用失败 | 检查网络和服务器状态 |

---

## 问题诊断

### 问题 1: 文章列表为空

**症状**: 日志显示 `文章列表长度: 0`

**可能原因**:
1. 服务器端接口未返回 `generatedArticles` 字段
2. 文章还未生成完成
3. 任务 ID 不匹配

**诊断步骤**:
```bash
# 检查服务器端文章
ssh ubuntu@124.221.247.107 "sudo -u postgres psql -d geo_system -c 'SELECT id, title, task_id FROM articles WHERE task_id = <TASK_ID>;'"

# 检查服务器端接口（需要 token）
# 在浏览器控制台执行：
fetch('/api/article-generation/tasks/<TASK_ID>')
  .then(r => r.json())
  .then(d => console.log('generatedArticles:', d.generatedArticles));
```

### 问题 2: 检查文章存在失败

**症状**: 日志显示 `❌ 同步异常` 在检查阶段

**可能原因**:
1. 本地数据库连接失败
2. `checkArticleExists` 方法有 bug

**诊断步骤**:
```bash
# 检查本地数据库连接
psql -U lzc -d geo_windows -c "SELECT 1;"

# 检查表结构
psql -U lzc -d geo_windows -c "\d articles"
```

### 问题 3: 获取文章内容失败

**症状**: 日志显示 `❌ 同步异常` 在获取内容阶段

**可能原因**:
1. API 调用失败（网络问题）
2. 文章 ID 不存在
3. 权限问题

**诊断步骤**:
```bash
# 检查服务器端文章内容
ssh ubuntu@124.221.247.107 "sudo -u postgres psql -d geo_system -c 'SELECT id, title, LENGTH(content) as content_length FROM articles WHERE id = <ARTICLE_ID>;'"

# 检查 API 响应（在浏览器控制台）
fetch('/api/article-generation/articles/<ARTICLE_ID>')
  .then(r => r.json())
  .then(d => console.log('content length:', d.content?.length));
```

### 问题 4: 保存到本地失败

**症状**: 日志显示 `❌ 同步失败` 在保存阶段

**可能原因**:
1. 数据库写入失败
2. 字段类型不匹配
3. 约束冲突

**诊断步骤**:
```bash
# 检查本地数据库日志
# 在 Electron 主进程日志中查看错误信息

# 手动测试插入
psql -U lzc -d geo_windows -c "INSERT INTO articles (user_id, title, keyword, content, task_id, created_at, updated_at) VALUES (1, 'Test', 'Test', 'Test', 999, NOW(), NOW());"
```

---

## 性能监控

### 同步耗时分析

| 阶段 | 预期耗时 | 实际耗时 | 备注 |
|------|---------|---------|------|
| 获取任务详情 | < 500ms | ___ | API 调用 |
| 检查文章存在 | < 100ms | ___ | 本地数据库查询 |
| 获取文章内容 | < 1000ms | ___ | API 调用 |
| 保存到本地 | < 200ms | ___ | 本地数据库写入 |
| **总计** | **< 2000ms** | ___ | 单篇文章 |

### 优化建议

如果同步耗时过长：
1. **批量获取文章内容**: 一次 API 调用获取多篇文章
2. **并发同步**: 同时同步多篇文章（注意控制并发数）
3. **缓存任务详情**: 避免重复获取相同任务的详情

---

## 测试报告模板

### 测试环境

- 操作系统: macOS / Windows
- Node.js 版本: ___
- Electron 版本: ___
- 数据库版本: PostgreSQL ___

### 测试结果

| 场景 | 状态 | 耗时 | 备注 |
|------|------|------|------|
| 正常同步 | ✅/❌ | ___ms | ___ |
| 多篇文章同步 | ✅/❌ | ___ms | ___ |
| 页面刷新后同步 | ✅/❌ | ___ms | ___ |
| 运行中任务同步 | ✅/❌ | ___ms | ___ |

### 发现的问题

1. **问题描述**: ___
   - **日志**: ___
   - **原因**: ___
   - **解决方案**: ___

2. **问题描述**: ___
   - **日志**: ___
   - **原因**: ___
   - **解决方案**: ___

### 总结

- **同步成功率**: ___% (成功数/总数)
- **平均同步耗时**: ___ms
- **是否满足需求**: ✅/❌
- **需要改进的地方**: ___

---

## 下一步行动

根据测试结果：

### 如果测试通过 ✅
1. 更新文档
2. 通知用户测试
3. 监控生产环境

### 如果测试失败 ❌
1. 分析日志找出问题
2. 修复代码
3. 重新测试

---

**测试人员**: ___  
**测试日期**: ___  
**测试结论**: ___
