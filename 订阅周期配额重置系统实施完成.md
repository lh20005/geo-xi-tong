# 订阅周期配额重置系统实施完成

## 实施概述

已成功将配额重置系统从**固定日历周期**升级为**用户订阅周期**模式。

### 核心改进

✅ **公平性**：每个用户都有独立的配额重置周期  
✅ **灵活性**：支持月度和年度套餐的不同重置周期  
✅ **动态性**：根据套餐的 `billing_cycle` 自动确定重置周期  
✅ **可预测**：用户清楚知道自己的配额重置时间

## 实施内容

### 1. 数据库迁移 (031)

**文件**: `server/src/db/migrations/031_subscription_cycle_quota_reset.sql`

#### 新增字段

```sql
ALTER TABLE user_subscriptions
ADD COLUMN quota_reset_anchor TIMESTAMP,      -- 配额重置锚点时间
ADD COLUMN quota_cycle_type VARCHAR(20);      -- 配额周期类型 (monthly/yearly)
```

#### 核心函数

1. **get_user_quota_period(user_id, feature_code)**
   - 计算用户当前配额周期
   - 基于订阅锚点时间和周期类型
   - 返回：period_start, period_end, cycle_type, subscription_end

2. **record_feature_usage(user_id, feature_code, amount)**
   - 记录功能使用量
   - 自动使用用户的配额周期

3. **check_feature_quota(user_id, feature_code, amount)**
   - 检查配额是否充足
   - 基于用户的配额周期计算使用量

4. **get_next_quota_reset_time(user_id)**
   - 获取用户下次配额重置时间

5. **get_quota_reset_description(user_id)**
   - 获取配额重置规则的可读描述
   - 例如："每月15号重置" 或 "每年3月20日重置"

#### 自动触发器

```sql
CREATE TRIGGER trigger_set_quota_cycle
  BEFORE INSERT OR UPDATE ON user_subscriptions
  FOR EACH ROW
  EXECUTE FUNCTION set_quota_cycle_on_subscription();
```

- 订阅创建时自动从套餐继承 `billing_cycle`
- 自动设置 `quota_reset_anchor` 为订阅开始时间

### 2. 服务层适配

**文件**: `server/src/services/SubscriptionService.ts`

#### 更新的方法

```typescript
// 使用数据库函数计算配额周期
private async getPeriodDates(userId: number): Promise<{...}> {
  const result = await pool.query(
    `SELECT period_start, period_end 
     FROM get_user_quota_period($1, 'articles_per_month')`,
    [userId]
  );
  // ...
}

// 使用数据库函数获取下次重置时间
private async getNextResetTime(userId: number): Promise<string> {
  const result = await pool.query(
    'SELECT get_next_quota_reset_time($1) as next_reset',
    [userId]
  );
  // ...
}
```

### 3. 测试脚本

**文件**: `server/src/scripts/test-subscription-cycle-quota.ts`

测试场景：
- ✅ 创建不同周期的测试用户（月度/年度）
- ✅ 计算配额周期
- ✅ 配额重置描述
- ✅ 配额使用记录
- ✅ 不同购买日期的对比
- ✅ 自动触发器测试
- ✅ 活跃用户配额信息汇总

## 使用示例

### 场景1：月度套餐用户

```
用户购买时间：2026-01-15
套餐类型：月度 (billing_cycle = 'monthly')
配额周期：monthly

配额重置规则：每月15号重置
第1周期：2026-01-15 ~ 2026-02-14
第2周期：2026-02-15 ~ 2026-03-14
第3周期：2026-03-15 ~ 2026-04-14
```

### 场景2：年度套餐用户

```
用户购买时间：2025-03-20
套餐类型：年度 (billing_cycle = 'yearly')
配额周期：yearly

配额重置规则：每年3月20日重置
第1周期：2025-03-20 ~ 2026-03-19
第2周期：2026-03-20 ~ 2027-03-19
```

### 场景3：不同用户的公平性

```
用户A：1月1日购买  → 每月1号重置
用户B：1月15日购买 → 每月15号重置
用户C：1月28日购买 → 每月28号重置

✅ 每个用户都有完整的30天使用周期
```

## 执行步骤

### 1. 执行数据库迁移

```bash
cd server
npx ts-node src/db/run-migration-031.ts
```

**预期输出**：
```
✅ 迁移 031 成功完成
   - 已添加配额重置锚点字段
   - 已创建订阅周期计算函数
   - record_feature_usage 函数已更新
   - check_feature_quota 函数已更新
   - 已创建自动设置配额周期触发器
   - 已创建配额重置时间查询函数
   - 配额重置现在基于用户订阅周期（月度/年度）
   - 现有用户配额锚点已初始化
```

### 2. 运行测试脚本

```bash
cd server
npx ts-node src/scripts/test-subscription-cycle-quota.ts
```

**测试内容**：
- 创建测试用户
- 验证配额周期计算
- 测试配额使用记录
- 验证触发器功能
- 显示所有用户配额信息

### 3. 验证现有用户

```sql
-- 查看所有用户的配额周期信息
SELECT 
  u.username,
  sp.plan_name,
  sp.billing_cycle,
  us.quota_cycle_type,
  us.quota_reset_anchor,
  get_quota_reset_description(u.id) as reset_rule,
  get_next_quota_reset_time(u.id) as next_reset
FROM users u
JOIN user_subscriptions us ON us.user_id = u.id
JOIN subscription_plans sp ON sp.id = us.plan_id
WHERE us.status = 'active'
  AND us.end_date > CURRENT_TIMESTAMP;
```

## 特殊场景处理

### 1. 中途调整配额

管理员调整配额时，**不重置使用量**，用户在当前周期内立即享受新配额。

```typescript
// 调整配额（保持当前周期）
await pool.query(`
  UPDATE user_subscriptions
  SET custom_quotas = jsonb_set(
    COALESCE(custom_quotas, '{}'::jsonb),
    '{articles_per_month}',
    '100'
  )
  WHERE user_id = $1 AND status = 'active'
`, [userId]);
```

### 2. 升级套餐

用户升级套餐时，**重置配额周期**，立即享受完整配额。

```typescript
// 升级套餐（重置周期）
await pool.query(`
  UPDATE user_subscriptions
  SET 
    plan_id = $1,
    quota_reset_anchor = CURRENT_TIMESTAMP,
    updated_at = CURRENT_TIMESTAMP
  WHERE user_id = $2 AND status = 'active'
`, [newPlanId, userId]);

// 清除旧配额使用记录
await pool.query(`
  DELETE FROM user_usage WHERE user_id = $1
`, [userId]);
```

### 3. 续费订阅

#### 提前续费（订阅未到期）
延长结束时间，**保持重置周期不变**。

```typescript
await pool.query(`
  UPDATE user_subscriptions
  SET 
    end_date = end_date + INTERVAL '1 month',
    updated_at = CURRENT_TIMESTAMP
  WHERE id = $1
`, [subscriptionId]);
```

#### 到期后续费
创建新订阅，**重新计算重置周期**。

```typescript
await pool.query(`
  INSERT INTO user_subscriptions (
    user_id, plan_id, status,
    start_date, end_date, quota_reset_anchor
  ) VALUES (
    $1, $2, 'active',
    CURRENT_TIMESTAMP,
    CURRENT_TIMESTAMP + INTERVAL '1 month',
    CURRENT_TIMESTAMP
  )
`, [userId, planId]);
```

## 前端展示建议

### 用户中心配额卡片

```tsx
<Card title="配额使用情况">
  <div>
    <Progress 
      percent={(used / limit) * 100} 
      format={() => `${used} / ${limit}`}
    />
    <div className="mt-2 text-gray-600">
      <CalendarOutlined /> {resetDescription}
      <ClockCircleOutlined className="ml-4" /> 
      距离重置：{daysUntilReset} 天
    </div>
  </div>
</Card>
```

### API 响应示例

```json
{
  "feature_code": "articles_per_month",
  "feature_name": "每月生成文章数",
  "used": 15,
  "limit": 50,
  "remaining": 35,
  "percentage": 30,
  "unit": "篇",
  "reset_description": "每月15号重置",
  "next_reset_time": "2026-02-15T00:00:00Z",
  "days_until_reset": 10
}
```

## 兼容性说明

### 现有用户处理

✅ **自动迁移**：迁移脚本会为所有现有用户初始化配额锚点  
✅ **无需手动操作**：基于现有的 `start_date` 自动设置  
✅ **不影响使用**：现有配额使用记录保持不变

### 免费版用户

免费版用户（永久订阅）也会有配额周期，但由于订阅时间很长（100年），实际上配额会在注册日重置。

## 性能优化

### 索引优化

```sql
-- 配额锚点查询索引
CREATE INDEX idx_user_subscriptions_quota_anchor 
  ON user_subscriptions(user_id, quota_reset_anchor) 
  WHERE status = 'active';

-- 配额周期查询索引
CREATE INDEX idx_user_usage_period 
  ON user_usage(user_id, feature_code, period_start, period_end);
```

### 旧数据清理

迁移脚本会自动清理超过3个周期的旧配额使用记录，保持数据库精简。

## 监控建议

### 关键指标

1. **配额重置分布**：监控用户配额重置日期的分布
2. **配额使用率**：按周期统计配额使用情况
3. **重置时间准确性**：验证配额重置是否按时执行

### 监控查询

```sql
-- 配额重置日期分布
SELECT 
  EXTRACT(DAY FROM quota_reset_anchor) as reset_day,
  COUNT(*) as user_count
FROM user_subscriptions
WHERE status = 'active'
  AND quota_cycle_type = 'monthly'
GROUP BY reset_day
ORDER BY reset_day;

-- 即将重置的用户（未来3天）
SELECT 
  u.username,
  get_next_quota_reset_time(u.id) as next_reset
FROM users u
WHERE get_next_quota_reset_time(u.id) BETWEEN 
  CURRENT_TIMESTAMP AND CURRENT_TIMESTAMP + INTERVAL '3 days'
ORDER BY next_reset;
```

## 故障排查

### 问题1：配额周期计算错误

**检查**：
```sql
SELECT * FROM get_user_quota_period(user_id, 'articles_per_month');
```

**可能原因**：
- quota_reset_anchor 未设置
- quota_cycle_type 与 billing_cycle 不匹配

### 问题2：配额未重置

**检查**：
```sql
SELECT 
  user_id, feature_code, 
  period_start, period_end,
  usage_count
FROM user_usage
WHERE user_id = ?
ORDER BY period_start DESC;
```

**可能原因**：
- 旧的配额记录未清理
- period_start/period_end 计算错误

### 问题3：触发器未生效

**检查**：
```sql
SELECT 
  us.quota_cycle_type,
  sp.billing_cycle
FROM user_subscriptions us
JOIN subscription_plans sp ON sp.id = us.plan_id
WHERE us.user_id = ?;
```

**修复**：
```sql
-- 手动同步配额周期类型
UPDATE user_subscriptions us
SET quota_cycle_type = sp.billing_cycle
FROM subscription_plans sp
WHERE us.plan_id = sp.id
  AND us.quota_cycle_type != sp.billing_cycle;
```

## 总结

✅ **实施完成**：订阅周期配额重置系统已全面上线  
✅ **向后兼容**：现有用户自动迁移，无需手动操作  
✅ **灵活扩展**：支持月度、年度等不同周期类型  
✅ **性能优化**：添加索引，自动清理旧数据  
✅ **测试完善**：提供完整的测试脚本和验证方法

---

**实施日期**: 2026-01-05  
**迁移版本**: 031  
**影响范围**: 所有用户配额系统  
**回滚方案**: 保留在迁移文件的 DOWN 部分
