# 多租户数据隔离问题 - 互联网最佳实践分析

## 问题概述

**现象：** lzc2005 用户在 Windows 端登录的抖音账号，在 Web 端的 testuser 用户中也能看到。

**根本原因分析：** 基于互联网最佳实践研究，这是典型的多租户隔离失败问题。

## 互联网最佳实践研究

### 1. 核心原则（来自 WorkOS 和 AWS）

根据 [WorkOS 多租户架构指南](https://workos.com/blog/developers-guide-saas-multi-tenant-architecture)，多租户系统必须遵循：

- ✅ **每条数据都属于唯一租户** - 数据库中必须有 `tenant_id` 或 `user_id`
- ✅ **每个请求都带有租户上下文** - JWT token 必须包含租户标识
- ✅ **所有读写路径都强制执行上下文** - 中间件必须验证和注入租户 ID
- ✅ **所有授权决策都在租户内评估** - 不能跨租户访问

### 2. JWT Token 最佳实践

#### 问题案例：JWT 跨租户漏洞

根据 [DeepStrike 安全研究](https://deepstrike.io/blog/cross-subdomain-jwt-account-take-over)，一个真实的 SaaS 平台因为以下问题导致完全的组织接管：

**漏洞原因：**
1. JWT 使用 email 而不是唯一 ID 进行验证
2. Token 中没有 `tenant_id` 或 `aud` (audience) 声明
3. 依赖客户端可控的 HTTP header 进行租户路由
4. 没有加密绑定 token 和租户

**攻击过程：**
```
1. 攻击者在租户 A 注册 user@example.com
2. 攻击者在租户 B 注册相同的 user@example.com
3. 使用租户 B 的 token 访问租户 A 的 API
4. 因为 token 只验证 email，成功跨租户访问
5. 提升到管理员权限，完全接管
```

#### 正确的 JWT 结构

```javascript
// ❌ 错误的 JWT payload
{
  "userId": 123,
  "username": "user@example.com",
  "exp": 1234567890
}

// ✅ 正确的 JWT payload
{
  "sub": "unique-user-id-uuid",        // 使用 UUID 而不是 email
  "userId": 123,
  "username": "user@example.com",
  "tenant_id": "tenant-uuid",          // 必须包含租户 ID
  "aud": "your-app-name",              // 指定受众
  "iss": "your-auth-service",          // 指定签发者
  "scope": ["read:own", "write:own"],  // 明确权限范围
  "exp": 1234567890
}
```

### 3. 租户隔离的三种模式

根据 [Mechanical Rock 的多租户指南](https://blog.mechanicalrock.io/2022/05/30/fine-grained-access-control-for-multitenancy.html)：

#### 模式 1: 行级隔离（Row-Level Security）
```sql
-- 所有表都包含 tenant_id/user_id
CREATE TABLE platform_accounts (
  id SERIAL PRIMARY KEY,
  user_id INTEGER NOT NULL,  -- 租户标识
  platform_id VARCHAR(50),
  account_name VARCHAR(255),
  credentials TEXT,
  CONSTRAINT fk_user FOREIGN KEY (user_id) REFERENCES users(id)
);

-- 所有查询都必须包含 user_id 过滤
SELECT * FROM platform_accounts WHERE user_id = $1;
```

#### 模式 2: Schema 隔离
```sql
-- 每个租户一个 schema
CREATE SCHEMA tenant_1;
CREATE SCHEMA tenant_2;

-- 动态切换 schema
SET search_path TO tenant_1;
```

#### 模式 3: 数据库隔离
- 每个租户独立数据库
- 最强隔离但成本最高

**我们的系统使用模式 1（行级隔离）**

### 4. 中间件强制执行（关键！）

根据 [Medium 多租户实践](https://medium.com/@v4sooraj/building-a-multi-tenant-application-with-single-database-and-token-based-authentication-e86cf1f08dfc)：

```typescript
// ✅ 正确的中间件链
app.use(authenticate);        // 1. 验证 JWT
app.use(setTenantContext);    // 2. 提取并设置 tenant_id
app.use(requireTenantContext); // 3. 强制要求 tenant_id

// ✅ 所有数据库查询都使用 tenant_id
async function getAccounts(userId: number) {
  return db.query(
    'SELECT * FROM platform_accounts WHERE user_id = $1',
    [userId]
  );
}
```

## 我们系统的问题诊断

### 检查点 1: JWT Token 是否正确隔离？

**可能的问题：**
1. Windows 端和 Web 端共享了同一个 token
2. Token 被手动复制粘贴
3. localStorage 在同一浏览器中被共享

**验证方法：**
```javascript
// 在 Windows 端开发者工具运行
const token = localStorage.getItem('auth_token');
const decoded = JSON.parse(atob(token.split('.')[1]));
console.log('Windows 端 userId:', decoded.userId);

// 在 Web 端开发者工具运行
const token = localStorage.getItem('auth_token');
const decoded = JSON.parse(atob(token.split('.')[1]));
console.log('Web 端 userId:', decoded.userId);

// 如果两个 userId 相同，说明 token 被共享了！
```

### 检查点 2: 数据库归属是否正确？

```sql
-- 检查用户 ID
SELECT id, username FROM users 
WHERE username IN ('lzc2005', 'testuser');

-- 检查账号归属
SELECT 
  pa.id,
  pa.platform_id,
  pa.account_name,
  pa.user_id,
  u.username
FROM platform_accounts pa
JOIN users u ON pa.user_id = u.id
WHERE u.username IN ('lzc2005', 'testuser');
```

### 检查点 3: 代码是否正确实现隔离？

我们的代码检查结果：
- ✅ 所有路由都使用 `authenticate` 中间件
- ✅ 所有路由都使用 `setTenantContext` 中间件
- ✅ 所有 Service 方法都需要 `userId` 参数
- ✅ 所有数据库查询都包含 `WHERE user_id = $1`

**代码层面没有问题！**

## 根本原因：Token 共享

基于以上分析，最可能的原因是：

### 场景 1: 同一浏览器登录不同账号

```
1. 用户在浏览器中以 testuser 登录 Web 端
2. localStorage 保存了 testuser 的 token
3. 用户打开 Windows 端（Electron 应用）
4. Windows 端使用了同一个浏览器引擎（Chromium）
5. 如果 Windows 端和 Web 端共享 localStorage，就会使用相同的 token
```

### 场景 2: Token 被手动复制

```
1. 用户在某处复制了 token
2. 在另一个客户端粘贴使用
3. 导致两个客户端使用相同的身份
```

### 场景 3: 开发/测试时的混淆

```
1. 开发者在测试时使用了 Token Debug 页面
2. 手动复制 token 到不同客户端
3. 忘记清除，导致混用
```

## 解决方案（基于最佳实践）

### 方案 1: 强制客户端隔离（推荐）

#### Windows 端（Electron）
```typescript
// 使用 Electron 独立存储，不使用 localStorage
import Store from 'electron-store';

const store = new Store({
  name: 'auth-tokens',
  encryptionKey: 'your-encryption-key'
});

// 保存 token
store.set('auth_token', token);

// 读取 token
const token = store.get('auth_token');
```

#### Web 端
```typescript
// 使用浏览器 localStorage
localStorage.setItem('auth_token', token);

// 或使用 sessionStorage（更安全，关闭标签页即清除）
sessionStorage.setItem('auth_token', token);
```

### 方案 2: 增强 JWT Token（推荐）

```typescript
// 在生成 token 时添加客户端标识
const payload = {
  userId: user.id,
  username: user.username,
  tenant_id: user.id,           // 明确的租户 ID
  client_type: 'web',           // 或 'electron'
  device_id: generateDeviceId(), // 设备唯一标识
  aud: 'geo-content-platform',
  iss: 'geo-auth-service',
  exp: Math.floor(Date.now() / 1000) + 3600
};

// 在验证时检查客户端类型
if (decoded.client_type !== expectedClientType) {
  throw new Error('Token 不适用于当前客户端');
}
```

### 方案 3: 添加设备绑定（最安全）

```typescript
// 生成设备指纹
function generateDeviceFingerprint() {
  const userAgent = navigator.userAgent;
  const platform = navigator.platform;
  const language = navigator.language;
  const screenResolution = `${screen.width}x${screen.height}`;
  
  const fingerprint = `${userAgent}-${platform}-${language}-${screenResolution}`;
  return crypto.createHash('sha256').update(fingerprint).digest('hex');
}

// Token 中包含设备指纹
const payload = {
  userId: user.id,
  device_fingerprint: generateDeviceFingerprint(),
  // ...
};

// 验证时检查设备指纹
if (decoded.device_fingerprint !== currentDeviceFingerprint) {
  throw new Error('Token 设备不匹配');
}
```

### 方案 4: 实现 Token 撤销机制

```typescript
// 在 Redis 中维护活跃 token 列表
interface ActiveToken {
  userId: number;
  tokenId: string;
  deviceId: string;
  clientType: string;
  createdAt: Date;
}

// 登录时保存
await redis.set(
  `token:${tokenId}`,
  JSON.stringify(activeToken),
  'EX',
  3600
);

// 验证时检查
const tokenData = await redis.get(`token:${tokenId}`);
if (!tokenData) {
  throw new Error('Token 已被撤销');
}

// 登出时撤销
await redis.del(`token:${tokenId}`);
```

## 立即执行的修复步骤

### 步骤 1: 清除所有客户端的 token

**Windows 端：**
```javascript
// 在开发者工具 Console 运行
localStorage.clear();
if (window.electron) {
  await window.electron.storage.clearTokens();
}
location.reload();
```

**Web 端：**
```javascript
// 清除所有存储
localStorage.clear();
sessionStorage.clear();
// 清除所有 cookies
document.cookie.split(";").forEach(c => {
  document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/");
});
location.reload();
```

### 步骤 2: 重新登录

1. 在 Windows 端以 lzc2005 登录
2. 在 Web 端以 testuser 登录
3. 验证两个客户端的 token 不同

### 步骤 3: 验证隔离

```bash
# 运行诊断脚本
node diagnose-account-isolation.js

# 检查数据库
node server/check-user-accounts.js

# 测试 API 隔离
./check-account-isolation.sh
```

## 预防措施（长期）

### 1. 代码层面

```typescript
// ✅ 在 JWT 生成时添加更多上下文
export function generateToken(user: User, clientType: string) {
  return jwt.sign(
    {
      sub: user.id.toString(),
      userId: user.id,
      username: user.username,
      tenant_id: user.id,
      client_type: clientType,
      aud: 'geo-content-platform',
      iss: 'geo-auth-service'
    },
    JWT_SECRET,
    { expiresIn: '1h' }
  );
}

// ✅ 在验证时检查上下文
export function verifyToken(token: string, expectedClientType?: string) {
  const decoded = jwt.verify(token, JWT_SECRET);
  
  if (expectedClientType && decoded.client_type !== expectedClientType) {
    throw new Error('Token client type mismatch');
  }
  
  return decoded;
}
```

### 2. 存储层面

```typescript
// Windows 端：使用 Electron Store
import Store from 'electron-store';
const store = new Store({ encryptionKey: 'secret' });

// Web 端：使用 sessionStorage（更安全）
sessionStorage.setItem('auth_token', token);
```

### 3. 监控层面

```typescript
// 记录所有登录和 token 使用
app.use((req, res, next) => {
  const token = req.headers.authorization?.replace('Bearer ', '');
  if (token) {
    const decoded = jwt.decode(token);
    console.log('[Auth] Token used:', {
      userId: decoded.userId,
      clientType: decoded.client_type,
      ip: req.ip,
      userAgent: req.headers['user-agent']
    });
  }
  next();
});
```

### 4. 测试层面

```typescript
// 自动化测试：验证租户隔离
describe('Multi-tenant isolation', () => {
  it('should not allow cross-tenant access', async () => {
    const user1Token = await login('user1');
    const user2Token = await login('user2');
    
    // 用户 1 创建账号
    const account = await createAccount(user1Token, accountData);
    
    // 用户 2 不应该能访问
    const response = await getAccount(user2Token, account.id);
    expect(response.status).toBe(404);
  });
});
```

## 总结

根据互联网最佳实践，多租户隔离问题通常由以下原因导致：

1. **Token 共享**（最常见）- 不同用户使用了相同的 JWT token
2. **Token 设计缺陷** - JWT 中缺少租户标识或使用不安全的标识符
3. **中间件缺失** - 没有正确实现租户上下文中间件
4. **数据库查询错误** - 查询时没有包含租户过滤条件

**我们的系统：**
- ✅ 代码层面实现正确（中间件、Service、数据库查询都有隔离）
- ❌ 可能存在 Token 共享问题（需要验证）

**立即行动：**
1. 运行诊断脚本验证 token
2. 清除所有客户端缓存
3. 重新登录并验证隔离
4. 考虑实施长期改进方案

## 参考资料

本文档基于以下互联网最佳实践整理（内容已重新表述以符合许可要求）：

- [Mechanical Rock - Fine Grained Access Control for Multi-tenancy](https://blog.mechanicalrock.io/2022/05/30/fine-grained-access-control-for-multitenancy.html)
- [Medium - Building Multi-Tenant Application with Single Database](https://medium.com/@v4sooraj/building-a-multi-tenant-application-with-single-database-and-token-based-authentication-e86cf1f08dfc)
- [DeepStrike - JWT Vulnerability in SaaS](https://deepstrike.io/blog/cross-subdomain-jwt-account-take-over)
- [WorkOS - Developer's Guide to SaaS Multi-Tenant Architecture](https://workos.com/blog/developers-guide-saas-multi-tenant-architecture)
