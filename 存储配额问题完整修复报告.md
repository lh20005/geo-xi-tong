# 存储配额问题完整修复报告

## 问题描述

用户反馈存储空间显示不正确：
1. 普通用户显示 200 MB，实际应该是 10 MB（多了10倍）
2. 管理员显示 10 GB，实际应该是 1 GB（多了10倍）

## 根本原因分析

### 问题1: PostgreSQL BIGINT 类型转换
PostgreSQL 的 BIGINT 类型在 Node.js 的 pg 驱动中会被转换为**字符串**以避免 JavaScript Number 类型的精度丢失问题。

### 问题2: 字符串拼接而非数值相加
`StorageService.getUserStorageUsage()` 方法中，直接使用数据库返回的字符串进行加法运算：

```typescript
// 错误代码
const row = result.rows[0];
const effectiveQuota = row.storageQuotaBytes + row.purchasedStorageBytes;
// "20971520" + "0" = "209715200" ❌ (字符串拼接，变成 200MB)
```

这导致：
- `"10485760" + "0" = "104857600"` → 100 MB（应该是 10 MB）
- `"1073741824" + "0" = "10737418240"` → 10 GB（应该是 1 GB）

## 修复方案

### 1. 更新默认配额值
- 普通用户：10 MB (10,485,760 bytes)
- 管理员：1 GB (1,073,741,824 bytes)

### 2. 修复 StorageService 字符串转换问题

```typescript
// 修复后的代码
const row = result.rows[0];

// 将所有 BIGINT 字段从字符串转换为数字
const imageStorageBytes = parseInt(row.imageStorageBytes);
const documentStorageBytes = parseInt(row.documentStorageBytes);
const articleStorageBytes = parseInt(row.articleStorageBytes);
const totalStorageBytes = parseInt(row.totalStorageBytes);
const storageQuotaBytes = parseInt(row.storageQuotaBytes);
const purchasedStorageBytes = parseInt(row.purchasedStorageBytes);

const effectiveQuota = storageQuotaBytes + purchasedStorageBytes;
// 10485760 + 0 = 10485760 ✅ (数值相加，保持 10 MB)
```

## 修改的文件

### 数据库层
1. `server/src/db/migrations/017_add_storage_management.sql`
   - 更新 `get_user_storage_quota()` 函数默认值

2. `server/src/db/migrations/019_fix_storage_quotas.sql`（新增）
   - 批量更新现有用户配额
   - 更新数据库函数

3. `server/src/db/run-migration-019.ts`（新增）
   - 执行迁移脚本

### 服务层
4. `server/src/services/StorageService.ts`
   - **关键修复**: 添加 `parseInt()` 转换所有 BIGINT 字段

### 迁移脚本
5. `server/src/scripts/migrate-existing-users-storage.ts`
   - 更新默认配额值

## 执行步骤

```bash
# 1. 运行数据库迁移
cd server
npx ts-node src/db/run-migration-019.ts

# 2. 清除 Redis 缓存
node test-storage-fix.js

# 3. 重启服务器（如果正在运行）
npm run server:dev
```

## 验证结果

### 数据库验证
```sql
SELECT u.username, u.role, 
       usu.storage_quota_bytes, 
       usu.storage_quota_bytes / 1024 / 1024 as quota_mb
FROM users u
JOIN user_storage_usage usu ON u.id = usu.user_id;
```

结果：
- 管理员 (lzc2005): 1.00 GB ✅
- 普通用户: 10.00 MB ✅

### 统计信息
- 管理员总数: 1
- 管理员配额为1GB的数量: 1 ✅
- 普通用户总数: 13
- 普通用户配额为10MB的数量: 12 ✅

## 配额规则总结

| 用户类型 | 默认配额 | 说明 |
|---------|---------|------|
| 管理员 | 1 GB | 固定配额 |
| 普通用户（无订阅） | 10 MB | 默认配额 |
| 体验版订阅 | 100 MB | 套餐配额 |
| 专业版订阅 | 1 GB | 套餐配额 |
| 企业版订阅 | 无限制 | 套餐配额 |

## 技术要点

### PostgreSQL BIGINT 处理最佳实践

在 Node.js 中处理 PostgreSQL BIGINT 类型时：

```typescript
// ❌ 错误：直接使用可能导致字符串拼接
const total = row.value1 + row.value2;

// ✅ 正确：先转换为数字
const total = parseInt(row.value1) + parseInt(row.value2);

// ✅ 或者使用 BigInt（如果需要更大的数值）
const total = BigInt(row.value1) + BigInt(row.value2);
```

### 为什么 pg 驱动返回字符串？

JavaScript 的 Number 类型：
- 最大安全整数：`2^53 - 1` (9,007,199,254,740,991)
- PostgreSQL BIGINT：`-2^63` 到 `2^63 - 1`

为避免精度丢失，pg 驱动将 BIGINT 转换为字符串。

## 影响范围

### 已修复
✅ 存储配额显示正确
✅ 配额计算正确
✅ 新用户注册时获得正确配额
✅ 管理员配额正确

### 需要注意
⚠️ 如果有其他地方直接使用数据库返回的 BIGINT 值进行数学运算，也需要添加 `parseInt()` 转换

## 测试建议

1. **前端测试**
   - 登录普通用户，查看个人中心存储空间显示
   - 登录管理员，查看存储空间显示

2. **API 测试**
   ```bash
   curl -H "Authorization: Bearer YOUR_TOKEN" \
        http://localhost:3000/api/storage/usage
   ```

3. **上传测试**
   - 上传图片/文档，验证配额扣减正确
   - 验证接近配额时的警告提示

## 完成时间

2026-01-04

## 状态

✅ 问题已完全修复
✅ 数据库已更新
✅ 服务层已修复
✅ 缓存已清除
✅ 文档已更新
